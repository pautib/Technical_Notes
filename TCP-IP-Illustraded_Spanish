# Resumen de 'TCP/IP Illustrated: The Protocols'

## √çndice de comandos Linux por cap√≠tulo

| Cap√≠tulo | Comando                         | Funci√≥n principal                                                                 |
|----------|----------------------------------|------------------------------------------------------------------------------------|
| 2        | `ifconfig`, `ip a`               | Muestra las interfaces de red y sus IPs                                           |
| 3        | `ping <IP>`                      | Comprueba conectividad y latencia usando ICMP Echo                               |
| 4        | `traceroute <IP>`                | Muestra el camino (hops) hasta un host                                            |
| 6        | `ip route`, `route -n`           | Ver rutas IP configuradas en la tabla de enrutamiento                            |
| 7        | `ping -t <ttl> <IP>`             | Prueba el tiempo de vida (TTL) y latencia                                         |
| 9        | `tcpdump`, `wireshark`           | Sniffea paquetes de red                                                           |
| 11       | `arp -a`, `ip neigh`             | Muestra la tabla ARP local                                                        |
| 12       | `tcpdump -i <iface> arp`         | Muestra tr√°fico ARP en una interfaz                                               |
| 13       | `dig`, `nslookup`, `host`        | Consulta registros DNS                                                            |
| 14       | `ss -tuln`, `netstat -an`        | Lista conexiones TCP/UDP y puertos en escucha                                     |
| 15       | `ss -i dst <IP>`                 | Muestra info extendida de conexi√≥n TCP hacia un destino                           |
| 16       | `tcpdump -n port 80`             | Captura paquetes en el puerto 80                                                  |
| 17       | `ss`, `lsof -i`                  | Informaci√≥n detallada de sockets y procesos                                       |
| 18       | `iptables`, `nft`                | Control de tr√°fico y filtrado de paquetes                                         |
| 19       | `ip link`, `ethtool`             | Gesti√≥n de interfaces Ethernet                                                    |
| 21       | `nc`, `telnet`                   | Herramientas para testear servicios y conexiones TCP                              |
| 22       | `watch -n 1 ss`                  | Refresca conexiones activas en tiempo real                                        |
| 23       | `tcpdump -X port 80`             | Captura y muestra payloads HTTP                                                   |
| 25       | `ip addr flush`, `ip route flush`| Borra configuraciones de red                                                      |
| 26       | `systemd-resolve --status`       | Muestra el estado del resolutor DNS                                               |
| 27       | `ip -s link`                     | Estad√≠sticas de paquetes de red por interfaz                                      |
| 28       | `ss -tp state established`       | Ver conexiones TCP establecidas                                                   |
| 29       | `snmpwalk`, `snmpget`            | Herramientas SNMP para monitorear dispositivos                                    |


----------

## Cap√≠tulo 1: Introducci√≥n

El libro presenta los protocolos TCP/IP desde un enfoque pr√°ctico con ejemplos reales de red. Define los protocolos clave (TCP, UDP, IP) y herramientas como `tcpdump` y `netstat`. El enfoque ser√° de abajo hacia arriba (desde la capa de enlace hasta la de aplicaci√≥n).

### ‚úÖ **Definici√≥n de TCP/IP**
**TCP/IP** (Transmission Control Protocol / Internet Protocol) es un **conjunto de protocolos de red** que permite la **comunicaci√≥n entre computadoras a trav√©s de redes interconectadas**, como Internet.

Es el **modelo est√°ndar de comunicaci√≥n** en redes modernas y define **c√≥mo se estructuran, direccionan, transmiten, enrutan y reciben los datos** entre sistemas.

---

### üîß **Componentes principales:**
TCP/IP no es un √∫nico protocolo, sino una **familia de protocolos** organizados en **4 capas funcionales**:

| Capa           | Funci√≥n principal                                           | Protocolos destacados              |
|----------------|-------------------------------------------------------------|------------------------------------|
| **Aplicaci√≥n** | Define c√≥mo las aplicaciones usan la red                    | HTTP, DNS, SMTP, FTP, SSH          |
| **Transporte** | Comunicaci√≥n de extremo a extremo                          | TCP (fiable), UDP (r√°pido)         |
| **Internet**   | Direccionamiento y enrutamiento entre redes                | IP, ICMP, ARP                      |
| **Enlace**     | Comunicaci√≥n dentro de una red local (f√≠sica o virtual)    | Ethernet, Wi-Fi, PPP               |

---

### üì¶ ¬øQu√© hace cada capa?

| Capa           | Qu√© hace                                                                                      |
|----------------|-----------------------------------------------------------------------------------------------|
| **Aplicaci√≥n** | Define **el formato de los datos** y protocolos como HTTP, DNS, SMTP. Las aplicaciones se comunican usando **nombres de dominio**, **sockets** y **puertos**. |
| **Transporte** | TCP o UDP **fragmentan los datos en segmentos**, gestionan conexiones, **garantizan entrega (TCP)** o simplemente env√≠an sin confirmaci√≥n (UDP). |
| **Internet**   | El protocolo IP **encapsula los segmentos en paquetes**, asigna **direcciones IP** de origen/destino y **enruta los datos** entre redes. |
| **Enlace**     | Se encarga de **entregar los paquetes a trav√©s del medio f√≠sico o virtual** (Ethernet, Wi-Fi), **resuelve direcciones MAC** con ARP si es necesario. |

---

### üíª Relevancia pr√°ctica para backend

- Comprender **sockets y puertos** te ayuda a dise√±ar **APIs y microservicios** que se comuniquen correctamente.
- Saber c√≥mo **TCP garantiza la entrega** es clave para:
  - Dise√±ar l√≥gica de reintentos
  - Entender problemas como **timeouts** y **p√©rdida de paquetes**
- Conocer **protocolos de aplicaci√≥n** (DNS, HTTP, SMTP) te permite:
  - Hacer debugging de errores complejos
  - Configurar servicios correctamente

---

### üß© Ejemplo real paso a paso (curl a una API)

Sup√≥n que ejecutas:  
```bash
curl https://api.ejemplo.com
```

| Capa           | Qu√© ocurre en ese paso de la comunicaci√≥n                                                                                 |
|----------------|----------------------------------------------------------------------------------------------------------------------------|
| **Aplicaci√≥n** | `curl` genera una petici√≥n HTTP. Se hace una consulta DNS para resolver `api.ejemplo.com` a una direcci√≥n IP.             |
| **Transporte** | Se establece una conexi√≥n TCP con el servidor mediante el *three-way handshake* (SYN ‚Üí SYN-ACK ‚Üí ACK).                    |
| **Internet**   | IP encapsula los segmentos TCP en paquetes, asigna direcciones IP origen/destino y los enruta entre redes.                |
| **Enlace**     | El paquete IP se encapsula en una trama Ethernet o Wi-Fi.                                                                 |

---

### üõ†Ô∏è Herramientas / Comandos √∫tiles

| Herramienta / Comando     | Uso principal                                                  | Capa TCP/IP relacionada        |
|---------------------------|----------------------------------------------------------------|-------------------------------|
| `ping`                    | Verifica conectividad IP mediante ICMP                         | Internet                      |
| `traceroute`              | Muestra la ruta que sigue un paquete hacia su destino          | Internet                      |
| `netstat` / `ss`          | Muestra puertos y conexiones activas                           | Transporte                    |
| `tcpdump` / `wireshark`   | Captura y analiza paquetes en todas las capas del modelo TCP/IP| Todas las capas               |
| `ifconfig` / `ip a`       | Muestra las interfaces de red, direcciones IP y estado         | Enlace / Internet             |
| `arp -a` / `ip neigh`     | Muestra la cach√© ARP (asociaciones IP ‚Üî MAC)                   | Enlace                        |
| `host`, `nslookup`, `dig` | Realiza consultas DNS para resolver nombres de dominio         | Aplicaci√≥n                    |



## üìò Cap√≠tulo 2: Capa de Enlace (Link Layer)

Describe los elementos de una red (hosts, routers, interfaces, direcciones IP, m√°scaras) y c√≥mo se comunican.


### ‚úÖ **Definici√≥n de la Capa de Enlace (Link Layer)**

La **Capa de Enlace**, tambi√©n llamada **Link Layer** o **Nivel de Enlace de Datos**, es la **primera capa del modelo TCP/IP** y se encarga de **transmitir tramas de datos entre dispositivos directamente conectados** en una red local (LAN).

Su funci√≥n principal es **encapsular los paquetes IP en tramas** que puedan enviarse a trav√©s de un medio f√≠sico (como cables Ethernet o se√±ales WiFi) y **asegurar que lleguen correctamente al siguiente nodo** (por ejemplo, un router o switch).

---

### üß† Lo esencial que debes saber

- La capa de enlace conecta f√≠sicamente tu m√°quina con la red a trav√©s de **Ethernet**, **WiFi**, o interfaces serie (como **PPP**).
- Se encarga de mover **tramas (frames)** entre dispositivos directamente conectados.
- Entrega los datos a la **capa IP** para su procesamiento.
- **MTU (Maximum Transmission Unit):** define el tama√±o m√°ximo que puede enviarse sin fragmentaci√≥n.
- **Loopback (`127.0.0.1`)**: interfaz virtual para pruebas locales, no sale a la red.

---

### üåê Protocolos comunes en la capa de enlace

#### üì° **1. Ethernet (IEEE 802.3)**

‚úÖ **Definici√≥n:**  Ethernet es el protocolo m√°s utilizado en redes LAN (Local Area Network). Define c√≥mo los dispositivos **formatean y transmiten tramas de datos** por cable a trav√©s de una red f√≠sica.

üîß **Caracter√≠sticas:**

-   Usa direcciones MAC para identificar dispositivos.
    
-   Tiene un MTU t√≠pico de **1500 bytes**.
    
-   Funciona con switches y NICs (tarjetas de red).
    
-   Define el formato de trama Ethernet: pre√°mbulo, MAC origen/destino, tipo, datos, y CRC.
    

----------

#### üì∂ **2. Wi-Fi (IEEE 802.11)**

‚úÖ **Definici√≥n:**  Wi-Fi es una familia de est√°ndares para comunicaci√≥n de red **inal√°mbrica** definida por IEEE 802.11. Opera tambi√©n en la capa de enlace, pero sobre medios **no f√≠sicos** (radiofrecuencia).

üîß **Caracter√≠sticas:**

-   Direcciones MAC como Ethernet.
    
-   Transmisi√≥n por el aire ‚Üí mayor latencia y posibles interferencias.
    
-   Seguridad gestionada por WPA/WPA2/WPA3.
    
-   MTU t√≠pica tambi√©n de 1500 bytes, aunque puede variar.
    

----------

#### üîå **3. PPP (Point-to-Point Protocol)**

‚úÖ **Definici√≥n:**  PPP es un protocolo de enlace usado para **comunicaciones punto a punto** entre dos nodos, especialmente en conexiones como m√≥dems, t√∫neles VPN o l√≠neas dedicadas.

üîß **Caracter√≠sticas:**

-   Encapsula protocolos de capa superior como IP.
    
-   Puede autenticar con PAP/CHAP.
    
-   Muy usado en conexiones **seriales, ADSL, PPPoE**, etc.
    
-   Reemplaz√≥ a SLIP por su mayor versatilidad.
    

----------

#### üßµ **4. SLIP (Serial Line Internet Protocol)**

‚úÖ **Definici√≥n:**  SLIP es un protocolo muy simple que permite la **transmisi√≥n de datagramas IP** a trav√©s de una **l√≠nea serial**. Fue utilizado antes de PPP, pero es **obsoleto**.

üîß **Caracter√≠sticas:**

-   No tiene control de errores, ni autenticaci√≥n.
    
-   Solo transmite IP (no m√∫ltiple protocolo).
    
-   Usado hist√≥ricamente con m√≥dems.
    
-   Reemplazado completamente por PPP.
    

----------

#### üåÄ **5. Loopback (127.0.0.1)**

‚úÖ **Definici√≥n:**  La interfaz **loopback** es una interfaz virtual interna del sistema operativo que **simula una red consigo mismo**. Su IP t√≠pica es **127.0.0.1**.

üîß **Caracter√≠sticas:**

-   Todo el tr√°fico enviado a 127.0.0.1 **nunca sale al exterior**.
    
-   Se usa para **pruebas locales, servicios backend y debugging**.
    
-   Las apps suelen escuchar en `localhost` para no exponerse p√∫blicamente.
    
-   El rendimiento es muy alto (tr√°fico no pasa por hardware f√≠sico).

---

### üì¶ Ejemplo simple

Cuando haces una petici√≥n HTTP, los datos de tu navegador viajan as√≠:

`HTTP ‚Üí TCP ‚Üí IP ‚Üí [Enlace]: los datos se encapsulan en una **trama Ethernet**` 

Esa trama contiene:

-   La direcci√≥n MAC de destino (por ejemplo, la del router)
    
-   La IP destino dentro del paquete IP encapsulado

---

### üë®‚Äçüíª Relevancia pr√°ctica para backend

- **MTU mal configurado** puede causar:
  - Fragmentaci√≥n IP innecesaria
  - Timeouts o p√©rdida de paquetes al subir archivos o hacer llamadas HTTP grandes
- Cuando ejecutas tu app en `localhost`, est√°s usando la **interfaz loopback**.
- Conocer la interfaz f√≠sica te ayuda a depurar problemas de **latencia o cortes de red** entre servicios que corren en m√°quinas distintas.

---

### üõ†Ô∏è Herramientas / comandos √∫tiles

| Comando                        | Funci√≥n                                                                    |
|-------------------------------|----------------------------------------------------------------------------|
| `ifconfig` / `ip a`           | Ver interfaces de red y sus direcciones IP                                 |
| `ping -s [tama√±o] [destino]`  | Probar el MTU enviando paquetes de tama√±o controlado                       |
| `tcpdump -i lo`               | Ver tr√°fico interno en la interfaz loopback (ej. entre microservicios)     |
| `netstat -i` / `ip link`      | Mostrar estad√≠sticas de red a nivel de interfaz (paquetes, errores, etc.)  |

---

### üß™ Ejemplos de uso pr√°ctico

#### üîß `ifconfig` / `ip a`

‚úÖ **Qu√© hace:**  Muestra las interfaces de red disponibles y sus direcciones IP asignadas.

üß™ **Ejemplo:** `ip a` 

üì§ **Salida:**
`1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default inet 127.0.0.1/8 scope host lo`

`3: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> inet 192.168.1.42/24 brd 192.168.1.255  scope  global eth0`

üß† **Comentario:**
Tipos de salida:
-   `lo` es la interfaz loopback (localhost).
    
-   `eth0` es tu interfaz Ethernet.
    
-   `inet` muestra las direcciones IP asignadas.

Aqu√≠ puedes ver que `eth0` tiene asignada la IP `192.168.1.42`. Tambi√©n ves si la interfaz est√° activa y operativa

üß™ **Ejemplo:** `ifconfig` 

üì§ **Salida t√≠pica:**
```bash
eth0:  flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu  1500  inet  192.168.1.42  netmask  255.255.255.0  broadcast  192.168.1.255  inet6  fe80::a00:27ff:fe4e:66a1  prefixlen  64  scopeid  0x20<link>  ether  08:00:27:4e:66:a1  txqueuelen  1000  (Ethernet)  RX  packets  10234  bytes  14568000  (13.8  MiB)  RX  errors  0  dropped  0  overruns  0  frame  0  TX  packets  9054 bytes  9834000  (9.3  MiB)  TX  errors  0  dropped  0  overruns  0  carrier  0  collisions  0` 
```

üß† **Comentario:**

-   La interfaz `eth0` est√° activa (`UP`) y tiene la IP `192.168.1.42`.
    
-   El campo `ether` muestra la direcci√≥n MAC.
    
-   Puedes ver tambi√©n estad√≠sticas de tr√°fico y errores en recepci√≥n (`RX`) o transmisi√≥n (`TX`).
    
-   El `mtu` es 1500, t√≠pico de redes Ethernet.

----------

#### üîß `ping -s [tama√±o] [IP]`

‚úÖ **Qu√© hace:**  Permite enviar paquetes ICMP de un tama√±o espec√≠fico, √∫til para probar el **MTU** sin fragmentar.

üß™ **Ejemplo:** `ping -s 1472 -M do 8.8.8.8` 

üì§ **Salida:** `64  bytes  from  8.8.8.8: icmp_seq=1 ttl=117 time=12.5 ms`

üß† **Explicaci√≥n:**
-   `1472` bytes + `28` de cabecera ICMP/IP = 1500 bytes (t√≠pico MTU).
-   `-M do` evita fragmentaci√≥n para detectar el l√≠mite real. Si falla, hay fragmentaci√≥n o un MTU menor en el camino.

Si el paquete es demasiado grande, la respuesta ser√≠a:
 `ping: local error: Message too long, mtu=1500`

----------

#### üîß `tcpdump -i lo`

‚úÖ **Qu√© hace:** Muestra el tr√°fico que pasa por la interfaz **loopback** (`lo`), es decir, comunicaciones locales en tu propia m√°quina.

üß™ **Ejemplos:** `sudo tcpdump -i lo` , `sudo tcpdump -i lo port 8080`

üì§ **Salida:** `IP  127.0.0.1.56732 > 127.0.0.1.8080: Flags [P.], length 64` 

üß† **Comentario:**  
Esto muestra que un servicio local (probablemente tu backend en localhost:8080) est√° recibiendo datos de otro proceso local.

----------

#### üîß `netstat -i` / `ip link`

‚úÖ **Qu√© hace:**  Muestra estad√≠sticas por interfaz: n√∫mero de paquetes enviados, errores, colisiones, etc.

üß™ **Ejemplo 1 (`netstat -i`):** `netstat -i` 

üì§ **Salida:**
```bash
Kernel Interface table
Iface   MTU Met RX-OK RX-ERR TX-OK TX-ERR ...
lo      65536 0   1000     0    1000    0   ...
eth0    1500  0   20000    2    19800   1   ...
```

üß† **Comentario:**
-   `Iface`: nombre de la interfaz de red (`lo` para loopback, `eth0` para Ethernet).
    
-   `MTU`: tama√±o m√°ximo de unidad de transmisi√≥n (por ejemplo, 1500 en Ethernet).
    
-   `RX-OK` / `TX-OK`: n√∫mero de **paquetes recibidos y enviados correctamente**.
    
-   `RX-ERR` / `TX-ERR`: n√∫mero de **errores en recepci√≥n o env√≠o**, como colisiones, paquetes da√±ados o descartados.
    
-   `lo`: tiene tr√°fico local entre procesos (ej. microservicios).
    
-   `eth0`: muestra el tr√°fico real de red, conectado f√≠sicamente o v√≠a Wi-Fi.


üß™ **Ejemplo 2 (`ip link`):** `ip link show` 

üì§ **Salida:** 

```bash
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00

2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000
    link/ether 08:00:27:4e:66:a1 brd ff:ff:ff:ff:ff:ff
```

üß† **Comentario:**  
`ip link show` es ideal para verificar si tu interfaz est√° activa (`UP`) y si tiene **una MAC v√°lida**, **un MTU correcto**, y **no est√° en estado DOWN** (ca√≠da).

## üìò Cap√≠tulo 3: IP ‚Äì Internet Protocol

Explica c√≥mo los datos viajan por la red en capas, usando `ping` y `traceroute` para comprobar conectividad. Describe encapsulamiento y c√≥mo una aplicaci√≥n env√≠a datos.

### üß† Lo esencial que debes saber

- **IP (Internet Protocol)** es el n√∫cleo de la comunicaci√≥n en red. Se encarga de **enrutar paquetes** (datagramas) entre dispositivos, incluso a trav√©s de **m√∫ltiples redes y routers**.
- Es un protocolo **no confiable y no orientado a conexi√≥n**:
  - Puede perder paquetes.
  - Puede entregarlos desordenados o duplicados.
  - No garantiza llegada ni orden.
- Cada paquete IP lleva una **cabecera de 20 bytes**, con campos importantes:

| Campo           | Qu√© representa                              |
|------------------|---------------------------------------------|
| `Version`        | 4 para IPv4                                 |
| `IHL`            | Longitud del encabezado IP                  |
| `Total Length`   | Tama√±o total del paquete IP                 |
| `TTL`            | L√≠mite de saltos para evitar loops          |
| `Protocol`       | 1 = ICMP, 6 = TCP, 17 = UDP                 |
| `Source IP`      | Direcci√≥n IP origen                         |
| `Destination IP` | Direcci√≥n IP destino                        |

- Soporta **fragmentaci√≥n** si el paquete excede el **MTU (Maximum Transmission Unit)** de una red intermedia.

---

### üë®‚Äçüíª Relevancia para backend

- Aunque t√∫ uses **TCP o UDP**, todo pasa encapsulado en **IP**.
- Entender IP ayuda a:
  - Diagnosticar **problemas de conectividad, latencia o rutas err√≥neas**.
  - Identificar **fragmentaci√≥n de paquetes**, especialmente si manejas archivos grandes o llamadas API pesadas.
  - Usar herramientas como `traceroute`, que dependen de **TTL** para rastrear rutas.
- Es vital cuando trabajas con:
  - Microservicios que se comunican entre regiones/redes.
  - Balanceadores de carga o redes definidas por software.
  - Logs o trazas a nivel de red.

---

### üõ†Ô∏è Comandos / herramientas √∫tiles

| Comando / Herramienta            | Funci√≥n                                                                 |
|----------------------------------|-------------------------------------------------------------------------|
| `ip addr show`                   | Muestra las interfaces de red y sus direcciones IP                     |
| `ip route`                       | Muestra la tabla de enrutamiento del sistema                           |
| `sudo tcpdump -n -i <iface> ip` | Captura paquetes IP y muestra sus encabezados (source/dest/protocolo) |
| `ping -s <tam> -M do <dest>`     | Prueba fragmentaci√≥n seg√∫n MTU de red                                  |

---

### üß™ Ejemplos pr√°cticos

### üîß `ip addr show`

‚úÖ **Qu√© hace:**  Muestra las interfaces activas y sus IPs asociadas.

üß™ **Ejemplo:** ``ip addr show``

üì§ **Salida esperada:**
```bash
3: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP>
    inet 192.168.1.45/24 brd 192.168.1.255 scope global eth0
```
üß† **Comentario:**  
Tu interfaz de red `eth0` tiene la IP `192.168.1.45`. Este comando te muestra tambi√©n el broadcast y la m√°scara.



### üîß `ip route`

‚úÖ **Qu√© hace:**  Muestra la tabla de rutas, es decir, c√≥mo se enruta el tr√°fico IP desde tu sistema.

üß™ **Ejemplo:** `ip route` 

üì§ **Salida esperada:**
`default via 192.168.1.1 dev eth0 192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.45` 

üß† **Comentario:**  
Todo el tr√°fico a Internet se env√≠a al **gateway 192.168.1.1**. La segunda l√≠nea indica que la red local est√° directamente conectada.


### üîß `sudo tcpdump -n -i eth0 ip`

‚úÖ **Qu√© hace:**  Captura tr√°fico IP en la interfaz seleccionada.

üß™ **Ejemplo:** `sudo tcpdump -n -i eth0 ip` 

üì§ **Salida simplificada:** `IP  192.168.1.45.54321 > 8.8.8.8.53: UDP, length 32` 

üß† **Comentario:**  
Este paquete est√° yendo del puerto `54321` de tu equipo hacia `8.8.8.8` por UDP. Ver√°s muchas de estas l√≠neas cuando hay actividad de red.

### üîß `ping -s 2000 -M do 8.8.8.8`

‚úÖ **Qu√© hace:**  Intenta enviar un paquete de 2000 bytes sin fragmentar, para probar si el MTU es suficiente.

üì§ **Respuesta esperada si el MTU es 1500:** 
`ping: local error: Message too long, mtu=1500` 

üß† **Comentario:**  
Este error indica que **el paquete es m√°s grande que el MTU**, y no puede fragmentarse (porque se us√≥ `-M do`). Es √∫til para depurar rutas con MTU bajo.


## üìòCap√≠tulo 4: ARP ‚Äì Address Resolution Protocol

 **ARP (Address Resolution Protocol)** se usa para **resolver direcciones IP en direcciones MAC**, necesarias en redes como Ethernet.

---

### üß† Lo esencial que debes saber    
-   Si tu equipo conoce la IP de destino, pero no su MAC, no puede enviarle un paquete directamente en una red local.
    
-   **Funcionamiento b√°sico:**
    
    1.  El host pregunta: **"¬øQui√©n tiene la IP 192.168.1.1?"**
        
    2.  El host con esa IP responde: **"Yo, y mi MAC es a0:ce:c8:41:22:58"**
        
    3.  Se guarda en la **cach√© ARP** para futuras transmisiones.

---

### üîÑ Tipos especiales de ARP

-   **Proxy ARP:** Una m√°quina responde por otra (com√∫n en redes NAT o VPN).
    
-   **Gratuitous ARP:** Un host anuncia su IP/MAC a la red para detectar conflictos o informar de cambios.

---

### üë®‚Äçüíª Relevancia para backend

-   Fallos misteriosos en la red local (ej. microservicios que no se alcanzan) pueden deberse a problemas de ARP.
    
-   **Conflictos de IP**, como dos m√°quinas usando la misma, se detectan a veces con Gratuitous ARP.
    
-   Diagn√≥sticos de **"connection refused" o timeouts locales** pueden deberse a:
    
    -   MAC incorrecta en cach√©.
        
    -   Dispositivo desconectado.
        
    -   Problemas de red bajo nivel.

---

### üõ†Ô∏è Comandos / herramientas √∫tiles (en tabla)

| Comando / Herramienta                  | Funci√≥n                                                                 |
|----------------------------------------|-------------------------------------------------------------------------|
| `ip neigh`                             | Muestra la cach√© ARP del sistema                                       |
| `sudo ip neigh del <IP> dev <iface>`   | Elimina una entrada ARP espec√≠fica (para forzar su renovaci√≥n)        |
| `arping <IP>`                          | Env√≠a una solicitud ARP al destino                                     |
| `sudo tcpdump -n -i <iface> arp`       | Captura tr√°fico ARP en tiempo real                                     |

---

### üß™ Ejemplos pr√°cticos

### üîß `ip neigh`

‚úÖ **Qu√© hace:**  
Muestra la **cach√© ARP**, es decir, qu√© MAC corresponde a qu√© IP en la red local.

üß™ **Ejemplo:** `ip neigh` 

üì§ **Salida esperada:** `192.168.1.1 dev eth0 lladdr a0:ce:c8:41:22:58 REACHABLE` 

üß† **Comentario:**  
Significa que `192.168.1.1` (probablemente tu gateway) est√° accesible y su MAC es `a0:ce:c8:41:22:58`.

### üîß `sudo ip neigh del 192.168.1.1 dev eth0`

‚úÖ **Qu√© hace:**  
Elimina una entrada espec√≠fica de la cach√© ARP para que el sistema tenga que **reconsultarla**.

üß† **Comentario:**  
√ötil cuando hay errores de red causados por una **cach√© ARP corrupta** o IPs mal asignadas.

### üîß `arping 192.168.1.1`

‚úÖ **Qu√© hace:**  
Env√≠a manualmente solicitudes ARP y mide el tiempo de respuesta.

üì§ **Respuesta esperada:**
`Unicast reply from  192.168.1.1  [A0:CE:C8:41:22:58]  1.123ms` 

üß† **Comentario:**  
Sirve para comprobar si un host **en tu red local** est√° activo y responde correctamente al nivel de enlace.

### üîß `sudo tcpdump -n -i eth0 arp`

‚úÖ **Qu√© hace:**  
Captura y muestra **solicitudes y respuestas ARP** que circulan por la red.

üì§ **Salida t√≠pica:**

```bash
ARP, Request who-has 192.168.1.1  tell  192.168.1.45, length  28 ARP, Reply 192.168.1.1 is-at a0:ce:c8:41:22:58, length  28
``` 

üß† **Comentario:**  
Puedes ver cu√°ndo tu equipo solicita la MAC de otra IP y c√≥mo responde el dispositivo correspondiente.

## üìò Cap√≠tulo 5: RARP ‚Äì Reverse Address Resolution Protocol

### üß† Lo esencial que debes saber

- **RARP (Reverse ARP)** es el inverso de ARP: permite que un dispositivo que **conoce su direcci√≥n MAC pero no su IP**, solicite su direcci√≥n IP a un servidor en la red.
- Fue dise√±ado para **m√°quinas sin disco** o sin almacenamiento permanente, como terminales tontos.
- **Funcionamiento:**
  1. El dispositivo env√≠a una solicitud: "Soy MAC XX:XX:XX:XX:XX:XX, ¬øqu√© IP debo usar?"
  2. Un servidor RARP responde con la IP asignada.

---

### üï∞Ô∏è RARP es hist√≥rico

- Hoy est√° **obsoleto** y ha sido reemplazado por **BOOTP y DHCP**.
- RARP no puede asignar otras configuraciones como:
  - Gateway
  - DNS
  - M√°scara de subred
- Conocerlo ayuda a entender la evoluci√≥n de los protocolos de configuraci√≥n de red.

---

### üîÑ Diferencia clave con ARP

| Protocolo | Entrada         | Salida             |
|-----------|------------------|---------------------|
| ARP       | IP conocida      | Devuelve la MAC     |
| RARP      | MAC conocida     | Devuelve la IP      |

---

### üë®‚Äçüíª Relevancia para backend

Aunque **no usar√°s RARP directamente**, puede ayudarte a:

- Comprender c√≥mo funcionaban los **arranques por red (PXE, BIOS)**.
- Diagnosticar problemas raros en entornos virtualizados o embebidos antiguos.
- Entender c√≥mo evolucion√≥ DHCP para cubrir sus limitaciones.

---

### üõ†Ô∏è Comandos / herramientas √∫tiles

> ‚ö†Ô∏è Como RARP est√° obsoleto, pocos sistemas lo usan, pero puedes capturar solicitudes si a√∫n existen en tu entorno.

| Comando / Herramienta         | Funci√≥n                                                   |
|-------------------------------|------------------------------------------------------------|
| `tcpdump -n -i <iface> rarp` | Captura solicitudes y respuestas RARP                     |
| `ip link` / `ip a`            | Ver direcci√≥n MAC (usada como identificador por RARP)     |

---

### üß™ Ejemplos pr√°cticos

#### üîß `tcpdump -n -i eth0 rarp`

‚úÖ **Qu√© hace:** Captura tr√°fico RARP en la red.

```bash
sudo tcpdump -n -i eth0 rarp
```

üì§ **Salida esperada:**
```bash
RARP, Request who-am-I 08:00:27:12:34:56 tell 08:00:27:12:34:56
RARP, Reply 192.168.1.45 is-at 08:00:27:12:34:56
```

üß† **Comentario:**  
El dispositivo con MAC `08:00:27:12:34:56` solicita su IP, y el servidor responde con `192.168.1.45`.

#### üîß `ip link`

‚úÖ **Qu√© hace:**  Muestra las direcciones MAC locales (clave para RARP).

```bash
ip link
```
üì§ **Salida esperada:**
```
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500
    link/ether 08:00:27:12:34:56 brd ff:ff:ff:ff:ff:ff
```
üß† **Comentario:**  La MAC mostrada ser√≠a la utilizada por un cliente RARP para identificarse.


## üìò Cap√≠tulo 6: ICMP ‚Äì Internet Control Message Protocol

### üß† Lo esencial que debes saber
- **ICMP** es un protocolo de soporte del protocolo IP, utilizado para **diagn√≥stico, control de errores y mensajes informativos** entre dispositivos.
- Aunque **no transporta datos de aplicaciones**, es **cr√≠tico para el funcionamiento de la red**.
- Se encapsula dentro de **paquetes IP** y tiene su propio campo de protocolo (n√∫mero 1).

---

### üîî Tipos comunes de mensajes ICMP

| Tipo / C√≥digo             | Funci√≥n                                      |
|---------------------------|----------------------------------------------|
| `Echo Request / Reply`    | Lo usa `ping` para verificar conectividad    |
| `Destination Unreachable` | El host no puede alcanzar el destino         |
| `Time Exceeded`           | El TTL ha llegado a cero (lo usa `traceroute`) |
| `Redirect`                | Sugiere usar otro gateway                    |
| `Fragmentation Needed`    | Usado en Path MTU Discovery                  |

---

### üë®‚Äçüíª Relevancia para backend

- **Ping y traceroute** dependen de ICMP, as√≠ que entenderlo es √∫til para:
  - Diagnosticar problemas de red (conexiones lentas o fallidas)
  - Ver si un host est√° vivo o no responde
  - Saber si tus servicios son **accesibles desde fuera**
- Algunas **configuraciones de firewall** o redes en la nube **bloquean ICMP**, lo que puede provocar falsos diagn√≥sticos de ca√≠da.

---

### üõ†Ô∏è Comandos / herramientas √∫tiles

| Comando / Herramienta                | Funci√≥n                                                  |
|--------------------------------------|-----------------------------------------------------------|
| `ping <IP>`                          | Envia solicitudes ICMP Echo para verificar conectividad  |
| `traceroute <IP>`                    | Usa ICMP (o UDP) para mostrar el camino hacia un host    |
| `sudo tcpdump -n -i <iface> icmp`    | Captura tr√°fico ICMP                                     |
| `iptables` / `ufw` / `nft`           | Para permitir o bloquear ICMP (Echo, TTL, etc.)          |

---

### üß™ Ejemplos pr√°cticos

#### üîß `ping <IP>`

‚úÖ **Qu√© hace:**  Env√≠a paquetes ICMP Echo Request y espera Echo Reply, ideal para verificar conectividad.

üß™ **Ejemplo:**
```bash
ping 8.8.8.8
```
üì§ **Salida esperada:**
```bash
64 bytes from 8.8.8.8: icmp_seq=1 ttl=118 time=14.2 ms
```
üß† **Comentario:**  
El host respondi√≥ correctamente, el TTL y el tiempo muestran latencia aproximada.

---
### üîß `traceroute <IP>`

‚úÖ **Qu√© hace:**  
Env√≠a paquetes con TTL incrementando para **ver los routers intermedios**.

üß™ **Ejemplo:** `traceroute google.com` 

üì§ **Salida esperada:**
```bash
1  192.168.1.1     1.123 ms
2  10.0.0.1        5.456 ms
3  core.isp.net    12.789 ms ...
```
üß† **Comentario:**  
Muestra cada salto hasta llegar al destino. Si se corta, puede indicar **filtro de ICMP o problemas de ruta**.

---

### üîß `sudo tcpdump -n -i eth0 icmp`

‚úÖ **Qu√© hace:**  
Captura paquetes ICMP en la interfaz de red especificada.

üß™ **Ejemplo:** `sudo tcpdump -n -i eth0 icmp` 

üì§ **Salida t√≠pica:**

```bash
IP 192.168.1.45 > 8.8.8.8: ICMP echo request, id 1, seq 1, length 64
IP 8.8.8.8 > 192.168.1.45: ICMP echo reply, id 1, seq 1, length 64` 
```
üß† **Comentario:**  
Puedes ver claramente las solicitudes y respuestas tipo `ping`, adem√°s de otros tipos de mensajes ICMP si se producen.

### üîß `iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT`

‚úÖ **Qu√© hace:**  
Permite expl√≠citamente que el sistema reciba `ping`.

üß† **Comentario:**  
Si tienes bloqueado ICMP, **no podr√°s hacer ping a ese servidor**, lo que puede confundir herramientas de monitoreo.

## üìò Cap√≠tulo 7: Ping ‚Äì Diagn√≥stico b√°sico de red con ICMP

### üß† Lo esencial que debes saber

- `ping` es una herramienta que utiliza **ICMP Echo Request y Echo Reply** para comprobar si un host es alcanzable en la red.
- Es uno de los comandos de red m√°s simples pero m√°s √∫tiles para diagn√≥stico.
- Por defecto, `ping` env√≠a paquetes ICMP de 64 bytes (puede ajustarse con `-s`).
- Mide:
  - **Latencia (tiempo ida y vuelta - RTT)**
  - **P√©rdida de paquetes**
  - **Variabilidad en el tiempo de respuesta (jitter)**

---

### üì¶ ¬øC√≥mo funciona internamente?

1. Se env√≠a un **ICMP Echo Request** al host destino.
2. Si el host responde, devuelve un **ICMP Echo Reply**.
3. `ping` calcula el tiempo entre el env√≠o y la respuesta.
4. Si no hay respuesta ‚Üí **Timeout** (puede deberse a red ca√≠da, ICMP bloqueado, o firewall).

---

### üë®‚Äçüíª Relevancia para backend

- Ideal para verificar si una **API, microservicio, o base de datos** est√° alcanzable desde tu servidor.
- Permite diferenciar entre:
  - **Problemas de red (sin respuesta a `ping`)**
  - **Problemas de aplicaci√≥n (responde a `ping`, pero no al puerto TCP)**

---

### üõ†Ô∏è Comandos / opciones √∫tiles de `ping`

| Comando                          | Descripci√≥n                                                   |
|----------------------------------|---------------------------------------------------------------|
| `ping <IP o hostname>`           | Verifica conectividad b√°sica                                  |
| `ping -c 4 <host>`               | Solo env√≠a 4 paquetes                                         |
| `ping -s <tam>`                  | Cambia el tama√±o del payload ICMP                             |
| `ping -M do -s <tam> <host>`     | Prueba si un paquete de cierto tama√±o se puede enviar sin fragmentar |
| `ping -i 0.2 <host>`             | Cambia el intervalo entre pings (√∫til para estresar la red)   |

---

### üß™ Ejemplos pr√°cticos

---

#### üîß `ping google.com`

‚úÖ **Qu√© hace:**  
Prueba si puedes alcanzar `google.com` desde tu sistema.

üì§ **Salida t√≠pica:**
```bash
64 bytes from 142.250.190.14: icmp_seq=1 ttl=118 time=15.2 ms
```

üß† **Comentario:**  
Respuesta normal. El TTL indica la cantidad de saltos restantes, y el `time` da una idea de la latencia real.

---

#### üîß `ping -c 4 8.8.8.8`

‚úÖ **Qu√© hace:**  
Env√≠a solo 4 paquetes y luego resume las estad√≠sticas.

üì§ **Salida:**
```bash
4 packets transmitted, 4 received, 0% packet loss, time 3004ms rtt min/avg/max/mdev = 13.209/14.237/15.064/0.685 ms
```
üß† **Comentario:**  
Ninguna p√©rdida de paquetes, latencia estable.

---

#### üîß `ping -s 1472 -M do 8.8.8.8`

‚úÖ **Qu√© hace:**  
Prueba si puedes enviar un paquete de 1472 bytes **sin fragmentar** (1472 + 28 = 1500, t√≠pico MTU de Ethernet).

üì§ **Error esperado si no cabe:**
```bash
ping: local error: Message too long, mtu=1500
```
üß† **Comentario:**  
Muy √∫til para **detectar problemas de MTU** o redes con t√∫neles como VPN.

#### üîß `ping -i 0.2 api.ejemplo.com`

‚úÖ **Qu√© hace:**  Env√≠a un ping cada 0.2 segundos para ver **jitter o p√©rdida temporal**.

üß† **Comentario:**  Ideal para simular una carga leve de red y detectar picos de latencia.


## üìò Cap√≠tulo 8: traceroute ‚Äì Rastreando el camino de los paquetes

### üß† Lo esencial que debes saber

- `traceroute` es una herramienta que permite **ver el camino (hops)** que sigue un paquete IP desde tu m√°quina hasta un destino.
- Utiliza **paquetes IP con TTL (Time To Live) creciente**:
  - El primer paquete tiene TTL=1 ‚Üí lo descarta el primer router y devuelve un mensaje ICMP ‚ÄúTime Exceeded‚Äù.
  - Luego TTL=2 ‚Üí lo descarta el segundo router, y as√≠ sucesivamente.
- Gracias a las respuestas ICMP generadas en cada salto, se puede **mapear la ruta completa** hasta el destino.

---

### üì¶ ¬øQu√© te dice traceroute?

- Qu√© **routers intermedios** est√°n involucrados entre t√∫ y el destino.
- D√≥nde se **pierde la conexi√≥n** si hay un fallo.
- Qu√© **latencia introduce cada router**.

> üìå En Linux se basa en **UDP** por defecto. En Windows (`tracert`) usa **ICMP Echo Request**.

---

### üë®‚Äçüíª Relevancia para backend

- Te ayuda a identificar **problemas de red m√°s all√° de tu infraestructura**.
- Muy √∫til para:
  - Diagnosticar **problemas de conectividad intermitentes**.
  - Ver si un servicio externo est√° lento por una **ruta de red ineficiente**.
  - Detectar **firewalls que filtran tr√°fico en ciertos saltos**.

---

### üõ†Ô∏è Comandos / opciones √∫tiles

| Comando                             | Descripci√≥n                                               |
|-------------------------------------|-----------------------------------------------------------|
| `traceroute <host>`                 | Rastrea ruta est√°ndar (UDP en Linux)                     |
| `traceroute -I <host>`              | Usa ICMP en lugar de UDP (como Windows)                  |
| `traceroute -T -p 443 <host>`       | Usa TCP, √∫til si los ICMP/UDP est√°n bloqueados           |
| `traceroute -n <host>`              | Muestra solo IPs, sin resolver DNS                       |

---

### üß™ Ejemplos pr√°cticos

---

#### üîß `traceroute google.com`

‚úÖ **Qu√© hace:**  
Muestra todos los routers por los que pasa el paquete hacia `google.com`.

üì§ **Salida t√≠pica:**
```bash
1 192.168.1.1 1.123 ms 1.110 ms 1.098 ms 2 10.0.0.1 4.456 ms 4.300 ms 4.312 ms 3 isp-gateway 12.789 ms 12.512 ms 12.398 ms ...
```

üß† **Comentario:**  Cada l√≠nea es un salto (hop). Se muestran tres medidas de tiempo por cada uno (reintentos).

---

#### üîß `traceroute -n github.com`

‚úÖ **Qu√© hace:**  Evita la resoluci√≥n DNS ‚Üí m√°s r√°pido y √∫til para diagn√≥sticos IP directos.

üì§ **Salida:**
``` bash
1 192.168.1.1 1.1 ms 2 10.0.0.1 4.3 ms 3 142.251.45.9 12.3 ms ...
```
üß† **Comentario:**  Muestra solo IPs, √∫til si el DNS est√° lento o si quieres enfocarte en direcciones.

---

#### üîß `traceroute -T -p 443 example.com`

‚úÖ **Qu√© hace:**  Usa paquetes TCP al puerto 443 (HTTPS), ideal si hay firewalls que **bloquean UDP o ICMP**.

üì§ **Ejemplo de salida t√≠pica:**

```bash
traceroute to example.com (93.184.216.34), 30 hops max, 60 byte packets
 1  192.168.1.1 (192.168.1.1)  1.123 ms  1.105 ms  1.097 ms
 2  10.0.0.1 (10.0.0.1)        4.456 ms  4.378 ms  4.312 ms
 3  100.64.0.1 (100.64.0.1)    8.791 ms  8.768 ms  8.701 ms
 4  93.184.216.34 (93.184.216.34)  13.002 ms  12.998 ms  13.010 ms
```

üß† **Comentario:**  Algunos entornos bloquean `traceroute` tradicional. Esta opci√≥n permite probar **como si fuera una conexi√≥n real** a un servicio.

-   Cada l√≠nea representa un **salto (hop)** entre routers desde tu equipo hasta `example.com`.
    
-   El √∫ltimo salto muestra la IP real del servidor web (en este caso, `93.184.216.34`).
    
-   El tiempo es el **RTT (round-trip time)** en milisegundos.
    
-   Al usar `-T`, est√°s simulando una conexi√≥n TCP real, √∫til cuando:
    
    -   ICMP est√° bloqueado.
        
    -   UDP no est√° permitido.
        
    -   Quieres saber c√≥mo se comporta el tr√°fico ‚Äúreal‚Äù hacia un **puerto abierto** (como 443 para HTTPS).

üö´ ¬øY si algo est√° bloqueado?

Podr√≠as ver asteriscos (`*`) como:
```bash
 3  * * *
```
Lo que significa que **el salto no respondi√≥ a los paquetes TCP**, ya sea porque lo filtra un firewall o el host no responde a paquetes SYN con TTL bajo.

---

## üìò Cap√≠tulo 9: IP Routing ‚Äì Enrutamiento de paquetes IP

### üß† Lo esencial que debes saber

- El **enrutamiento IP** es el proceso mediante el cual un sistema determina **a d√≥nde enviar un paquete IP**.
- Cada equipo con red tiene una **tabla de rutas (routing table)** que le indica:
  - Qu√© interfaz usar
  - Qu√© gateway utilizar si el destino no est√° en la red local

- Tipos de rutas:
  - **Red local (directa)**: si el destino est√° en tu red, se env√≠a directamente.
  - **Gateway o ruta por defecto**: si el destino no est√° en tu red, se env√≠a al **router (gateway)**.

---

### üì¶ ¬øQu√© contiene una tabla de rutas?

| Campo              | Qu√© representa                                |
|--------------------|------------------------------------------------|
| `Destination`      | La red destino (ej. `192.168.1.0/24`)          |
| `Gateway`          | A d√≥nde reenviar si no est√° en red local       |
| `Genmask` / Prefix | La m√°scara de red o prefijo CIDR               |
| `Iface`            | La interfaz de red usada (eth0, wlan0...)      |

---

### üë®‚Äçüíª Relevancia para backend

- Si tu servidor **no tiene una ruta adecuada**, no podr√° responder ni enviar peticiones a ciertos destinos.
- Muy √∫til para:
  - Diagnosticar problemas de red entre servicios
  - Ver si est√°s saliendo por la IP esperada (red p√∫blica/privada)
  - Entender configuraciones de VPN, NAT, contenedores

---

### üõ†Ô∏è Comandos / herramientas √∫tiles

| Comando                        | Funci√≥n                                                  |
|-------------------------------|----------------------------------------------------------|
| `ip route`                    | Muestra la tabla de rutas                                |
| `ip route get <IP>`           | Muestra la ruta que seguir√≠a un paquete a esa IP        |
| `route -n`                    | Muestra la tabla en formato cl√°sico (sin resoluci√≥n DNS)|
| `traceroute <host>`           | Muestra los saltos que sigue un paquete hasta el destino|
| `ip route add/del`            | A√±ade o elimina rutas manualmente                       |

---

### üß™ Ejemplos pr√°cticos

---

#### üîß `ip route`

‚úÖ **Qu√© hace:**  Muestra las rutas conocidas por el sistema.

üì§ **Salida t√≠pica:**
```bash
default via 192.168.1.1 dev eth0 192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.45
```

üß† **Comentario:**
- Todo lo que no sea de tu red (`default`) se manda al gateway `192.168.1.1`.
- La red local `192.168.1.0/24` se maneja directamente por `eth0`.

---

#### üîß `ip route get 8.8.8.8`

‚úÖ **Qu√© hace:**  
Calcula qu√© ruta seguir√≠a un paquete hacia una IP concreta.

üì§ **Salida:**
```bash
8.8.8.8 via 192.168.1.1 dev eth0 src 192.168.1.45
```

üß† **Comentario:**  
Muestra que para alcanzar 8.8.8.8, se usar√° el gateway 192.168.1.1 por la interfaz eth0, y se usar√° tu IP local 192.168.1.45 como origen.

---

#### üîß `route -n`

‚úÖ **Qu√© hace:**  Muestra la tabla de rutas en formato cl√°sico, sin resolver nombres.

üì§ **Salida t√≠pica:**
```bash
Destination Gateway Genmask Iface 0.0.0.0 192.168.1.1 0.0.0.0 eth0 192.168.1.0 0.0.0.0 255.255.255.0 eth0
```


üß† **Comentario:**  
`0.0.0.0` como destino significa ‚Äútodo lo que no tenga una ruta m√°s espec√≠fica‚Äù.

---

#### üîß `ip route add 10.10.0.0/16 via 192.168.1.10`

‚úÖ **Qu√© hace:**  Agrega una ruta para la red `10.10.0.0/16` a trav√©s del gateway `192.168.1.10`.

üß† **Comentario:**  
√ötil si necesitas acceder a redes privadas que no est√°n en tu tabla por defecto (como una red interna de empresa o una VPN).

---

## üìò Cap√≠tulo 10: Dynamic Routing Protocols ‚Äì Protocolos de enrutamiento din√°mico

### üß† Lo esencial que debes saber

- Los **protocolos de enrutamiento din√°mico** permiten que los routers y equipos actualicen autom√°ticamente sus tablas de rutas, sin configuraci√≥n manual.
- A diferencia del enrutamiento est√°tico (con rutas fijas), el enrutamiento din√°mico:
  - Aprende nuevas rutas autom√°ticamente
  - Se adapta a cambios en la red (ca√≠das, nuevos nodos, etc.)
  - Utiliza mensajes para intercambiar informaci√≥n de red

---

### üì¶ Protocolos m√°s comunes

| Protocolo | Caracter√≠sticas principales                                          |
|-----------|----------------------------------------------------------------------|
| **RIP**   | Muy simple, basado en el n√∫mero de saltos. M√°ximo 15 hops.          |
| **OSPF**  | Usa el algoritmo de Dijkstra. Muy eficiente. Interior a una red.    |
| **BGP**   | Utilizado entre sistemas aut√≥nomos (ej. proveedores de Internet).   |

---

### üîÅ Funcionamiento general

- Los routers que usan estos protocolos:
  - **Env√≠an peri√≥dicamente anuncios de enrutamiento** a sus vecinos
  - Detectan enlaces ca√≠dos
  - **Actualizan rutas autom√°ticamente** en su tabla de enrutamiento
- Esto permite que una red **"se autorrecupere"** ante fallos de enlaces o routers.

---

### üë®‚Äçüíª Relevancia para backend

- Aunque no configures routing como backend developer, entenderlo es clave si trabajas en:
  - **Infraestructura cloud compleja** (AWS, GCP, redes h√≠bridas)
  - **Microservicios distribuidos** en distintas zonas o regiones
  - **Conectividad entre servicios en distintas VPCs o redes definidas por software**
- Puedes encontrarte con fallos que dependen de **rutas que cambian din√°micamente**, por ejemplo si un servidor deja de ser accesible tras una ca√≠da de red.

---

### üõ†Ô∏è Herramientas / conceptos √∫tiles

| Herramienta / Concepto   | Funci√≥n                                                                 |
|---------------------------|------------------------------------------------------------------------|
| `ip route`                | Ver tabla de rutas (est√°ticas y din√°micas)                            |
| `traceroute`              | Ver el camino real que toman los paquetes                             |
| `zebra` / `quagga` / `FRRouting` | Daemon para soportar RIP, OSPF y BGP en Linux (avanzado)      |
| `bird`, `bgpd`, `ospfd`  | Daemons espec√≠ficos de routing din√°mico                               |

---

### üß™ Ejemplos y conceptos clave

---

#### üîß RIP (Routing Information Protocol)

‚úÖ **Qu√© hace:**  
Envia actualizaciones cada 30 segundos. Usa el **n√∫mero de saltos** como m√©trica.

üß† **Comentario:**  
Es muy simple, pero no escala bien en redes grandes. M√°ximo 15 saltos ‚Üí ideal solo para redes peque√±as o aisladas.

---

#### üîß OSPF (Open Shortest Path First)

‚úÖ **Qu√© hace:**  
Calcula rutas m√°s cortas usando **Dijkstra**. Divide la red en √°reas y es muy escalable.

üß† **Comentario:**  
Es el protocolo m√°s usado en redes empresariales internas (intra-AS). Ofrece convergencia r√°pida y granularidad.

---

#### üîß BGP (Border Gateway Protocol)

‚úÖ **Qu√© hace:**  
Controla el enrutamiento **entre sistemas aut√≥nomos (AS)**, como proveedores de internet o redes globales.

üß† **Comentario:**  
Es el protocolo que **hace funcionar Internet**. Muy robusto, pero tambi√©n complejo. Define **qui√©n anuncia qu√© redes** a qui√©n.

---

#### üîß `traceroute` y enrutamiento din√°mico

‚úÖ **Qu√© muestra?:**  
Si la ruta cambia con el tiempo (por fallos, balanceo, etc.), `traceroute` lo reflejar√°.

üì§ **Ejemplo:**
```bash
1 192.168.1.1 2 isp-router1 3 isp-core1 ...
```


üß† **Comentario:**  
Si un salto desaparece o cambia, puede indicar que un protocolo de routing din√°mico ha **reconstruido la ruta** por otro camino.

---

## üìò Cap√≠tulo 11: UDP ‚Äì User Datagram Protocol

### üß† Lo esencial que debes saber

- **UDP** es un protocolo de transporte **ligero y no confiable** que se encuentra sobre IP.
- A diferencia de TCP:
  - **No establece conexi√≥n**
  - **No garantiza entrega**
  - **No ordena los mensajes**
  - **No retransmite** paquetes perdidos

- Pero es mucho m√°s r√°pido y eficiente para ciertos usos, ya que:
  - A√±ade muy poca sobrecarga (solo 8 bytes de cabecera)
  - Es ideal para aplicaciones **en tiempo real o tolerantes a p√©rdida**

---

### üì¶ Estructura del datagrama UDP

| Campo            | Tama√±o | Descripci√≥n                                 |
|------------------|--------|---------------------------------------------|
| Source Port      | 2 bytes| Puerto origen                               |
| Destination Port | 2 bytes| Puerto destino                              |
| Length           | 2 bytes| Longitud total del datagrama UDP            |
| Checksum         | 2 bytes| Verifica errores en cabecera + datos        |

---

### üë®‚Äçüíª Relevancia para backend

- Muchos protocolos populares de backend usan UDP:
  - **DNS**
  - **NTP**
  - **DHCP**
  - Servicios propios de baja latencia o telemetr√≠a
- Algunas APIs internas de microservicios en entornos de alta disponibilidad tambi√©n usan UDP para **notificaciones, descubrimiento o logs livianos**
- Ideal para situaciones donde **la velocidad importa m√°s que la fiabilidad**

---

### üõ†Ô∏è Comandos / herramientas √∫tiles

| Comando / Herramienta             | Funci√≥n                                                                 |
|----------------------------------|--------------------------------------------------------------------------|
| `ss -u -l`                        | Ver puertos UDP en escucha                                              |
| `tcpdump udp`                    | Captura tr√°fico UDP                                                     |
| `netstat -u -n`                   | Ver conexiones UDP                                                      |
| `dig`                             | Ejecuta consultas DNS (usa UDP por defecto)                             |
| `nc -u`                           | Cliente UDP manual (netcat)                                             |

---

### üß™ Ejemplos pr√°cticos

#### üîß `ss -u -l`

‚úÖ **Qu√© hace:**  
Muestra puertos **UDP en escucha** en el sistema.

üì§ **Salida t√≠pica:**
```bash
Netid State Local Address:Port udp UNCONN 0.0.0.0:12345
```


üß† **Comentario:**  
Un servicio local est√° escuchando en el puerto 12345 por UDP. `UNCONN` indica que no hay conexi√≥n establecida (UDP es connectionless).

---

#### üîß `tcpdump udp`

‚úÖ **Qu√© hace:**  
Captura y muestra solo paquetes UDP.

üì§ **Salida t√≠pica:**
```bash
IP 192.168.1.10.5353 > 224.0.0.251.5353: UDP, length 120
```

üß† **Comentario:**  
Aqu√≠ se muestra un datagrama UDP enviado a una direcci√≥n multicast (como en mDNS). Tambi√©n puedes capturar DNS, DHCP, etc.

---

#### üîß `netstat -u -n`

‚úÖ **Qu√© hace:**  
Lista conexiones activas y puertos UDP abiertos (sin resolver DNS).

üì§ **Salida:**
```bash
udp 0 0 0.0.0.0:123 0.0.0.0:*
```

üß† **Comentario:**  
El servicio est√° escuchando en UDP:123 (probablemente NTP). UDP no muestra "estados" como TCP.

---

#### üîß `dig google.com`

‚úÖ **Qu√© hace:**  
Env√≠a una consulta DNS a los servidores p√∫blicos (por defecto usa UDP).

üì§ **Salida resumida:**
```bash
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 12345 ;; QUESTION SECTION: ;google.com. IN A

;; ANSWER SECTION: google.com. 300 IN A 142.250.190.78
```


üß† **Comentario:**  
Consulta DNS est√°ndar. `dig` usa UDP por defecto, aunque cambia a TCP si la respuesta es demasiado grande.

---

### üîß `echo "hello" | nc -u 127.0.0.1 12345`

‚úÖ **Qu√© hace:**  
Env√≠a un mensaje UDP manualmente a `localhost:12345`.

üß† **Comentario:**  
Muy √∫til para probar si tu servicio UDP est√° recibiendo datos correctamente.

---

## üìò Cap√≠tulo 12: Broadcasting and Multicasting

### üß† Lo esencial que debes saber

Este cap√≠tulo trata sobre **formas especiales de comunicaci√≥n IP** en las que un paquete se env√≠a **a m√∫ltiples receptores**, en lugar de a un √∫nico destino:

---

### üì¢ Broadcasting

- **Broadcast** significa enviar un paquete a **todos los hosts de una red local**.
- Se usa en protocolos como:
  - **ARP**
  - **DHCP (cuando no se conoce a√∫n la IP del servidor)**
- Existen dos tipos:
  - **Directed Broadcast**: a la direcci√≥n final de la red (ej. `192.168.1.255`)
  - **Limited Broadcast**: a `255.255.255.255` (nunca sale de la red local)

üß† **Importante:** Los routers **no reenv√≠an broadcasts**, por lo que solo funcionan dentro de una red local.

---

### üì° Multicasting

- **Multicast** permite enviar paquetes a **m√∫ltiples destinos espec√≠ficos**, sin afectar a todos los hosts.
- Usado por aplicaciones como:
  - **Streaming multimedia**
  - **Protocolo de descubrimiento (mDNS, SSDP)**
  - **Protocolos de routing din√°mico (OSPF, RIPng, etc.)**
- Utiliza direcciones IP especiales: `224.0.0.0` a `239.255.255.255`
  - Ejemplo: `224.0.0.1` (todos los hosts)

üß† **Importante:** A diferencia del broadcast, **los routers pueden reenviar multicast** si est√°n configurados correctamente.

---

### üë®‚Äçüíª Relevancia para backend

- Servicios que usan descubrimiento autom√°tico o comunicaci√≥n distribuida (como **microservicios en red local** o **contenedores**) pueden apoyarse en **multicast o broadcast**.
- Algunos sistemas legados o protocolos embebidos a√∫n usan broadcast para configurarse.
- Entender estas t√©cnicas ayuda a:
  - Depurar tr√°fico inesperado
  - Detectar **anuncios de servicios** (como impresoras, c√°maras IP, etc.)
  - Controlar qu√© se expone en red local

---

### üõ†Ô∏è Comandos / herramientas √∫tiles

| Comando / Herramienta              | Funci√≥n                                                                 |
|------------------------------------|--------------------------------------------------------------------------|
| `tcpdump -i <iface> broadcast`     | Captura tr√°fico broadcast                                               |
| `tcpdump -i <iface> multicast`     | Captura tr√°fico multicast                                               |
| `ping 224.0.0.1`                   | Prueba si tu m√°quina puede enviar/recibir multicast (todos los hosts)   |
| `netstat -g` / `ip maddr`          | Muestra los grupos multicast suscritos                                 |
| `ssdp-discovery` / `avahi-browse`  | Descubre servicios v√≠a multicast en red local                           |

---

### üß™ Ejemplos pr√°cticos

#### üîß `tcpdump -i eth0 broadcast`

‚úÖ **Qu√© hace:**  
Captura paquetes que usan direcciones broadcast.

```bash
ARP, Request who-has 192.168.1.1 tell 192.168.1.45
```
üß† **Comentario:**  Aqu√≠ tu sistema est√° pidiendo a toda la red qui√©n tiene una determinada IP.


#### üîß `ping 224.0.0.1`

‚úÖ **Qu√© hace:**  Env√≠a paquetes ICMP multicast a todos los hosts de la red que lo soporten.

```bash
64 bytes from 192.168.1.12: icmp_seq=1 ttl=1 time=1.3 ms
64 bytes from 192.168.1.34: icmp_seq=1 ttl=1 time=1.9 ms
```
üß† **Comentario:**  
Est√°s viendo respuestas de otros hosts en tu red que escuchan en ese grupo multicast.


#### üîß `netstat -g` o `ip maddr`

‚úÖ **Qu√© hace:**  
Muestra los **grupos multicast** a los que tu m√°quina est√° suscrita.

```bash
224.0.0.1
239.255.255.250 
```

üß† **Comentario:**  
Tu m√°quina puede recibir paquetes enviados a esas direcciones multicast (SSDP, mDNS, etc.).

#### üîß `tcpdump -i eth0 multicast`

‚úÖ **Qu√© hace:**  
Captura tr√°fico multicast en la interfaz especificada.

```bash
IP 192.168.1.45.5353 > 224.0.0.251.5353: UDP, length 100
```

üß† **Comentario:**  
Tr√°fico t√≠pico de mDNS (Bonjour, Avahi, etc.). Puedes usarlo para descubrir dispositivos y servicios.


## üìò Cap√≠tulo 13: IGMP ‚Äì Internet Group Management Protocol

### üß† Lo esencial que debes saber

- **IGMP** es un protocolo de la capa de red utilizado por los hosts y routers para gestionar la **suscripci√≥n a grupos multicast**.
- Solo se utiliza con **IPv4** (en IPv6 se reemplaza por MLD ‚Äì Multicast Listener Discovery).
- Permite que un host informe a los routers cercanos que **quiere recibir tr√°fico multicast** de un grupo concreto (por ejemplo, `224.0.0.1`).
- No transporta datos; solo gestiona la **participaci√≥n en grupos multicast**.

---

### üì¶ ¬øC√≥mo funciona IGMP?

1. Un host quiere unirse a un grupo multicast ‚Üí **env√≠a un mensaje IGMP Membership Report**.
2. El router detecta ese mensaje y **empieza a reenviar tr√°fico** para ese grupo a la red local.
3. Si el host ya no desea recibir tr√°fico ‚Üí **se puede enviar un Leave Group** (en IGMPv2+).
4. El router puede enviar peri√≥dicamente **queries IGMP** para verificar qu√© hosts siguen interesados.

---

### üî¢ Versiones de IGMP

| Versi√≥n   | Caracter√≠sticas clave                                             |
|-----------|--------------------------------------------------------------------|
| IGMPv1    | B√°sico, sin Leave Group                                            |
| IGMPv2    | Soporta Leave Group y tiempo de espera ajustable                  |
| IGMPv3    | Permite filtrar por fuentes espec√≠ficas (source-specific multicast)|

---

### üë®‚Äçüíª Relevancia para backend

- Aunque como desarrollador backend **no configures IGMP directamente**, puede afectarte si:
  - Usas servicios que **dependen de multicast** (descubrimiento, streaming, protocolos distribuidos).
  - Trabajas en sistemas embebidos, IoT, o redes locales cerradas.
  - Est√°s debugueando tr√°fico multicast que **no llega a tu servicio** (porque tu host no est√° inscrito en el grupo).

- Muchos **contenedores o m√°quinas virtuales** no manejan bien IGMP por defecto, lo que puede romper servicios multicast internos.

---

### üõ†Ô∏è Comandos / herramientas √∫tiles

| Comando / Herramienta             | Funci√≥n                                                                 |
|----------------------------------|--------------------------------------------------------------------------|
| `ip maddr`                       | Ver los grupos multicast a los que la interfaz est√° suscrita            |
| `netstat -g`                     | Ver membres√≠as multicast actuales                                       |
| `tcpdump igmp`                   | Captura mensajes IGMP                                                   |
| `ping 224.0.0.1`                 | Ver si otros hosts responden a una IP multicast est√°ndar                |
| `smcroute`, `igmpproxy`, `avahi-daemon` | Herramientas para gestionar multicast y proxies IGMP                |

---

### üß™ Ejemplos pr√°cticos

#### üîß `ip maddr`

‚úÖ **Qu√© hace:**  
Muestra los grupos multicast a los que est√° suscrita cada interfaz de red.

```bash
eth0
    link  01:00:5e:00:00:01
    inet  224.0.0.1
    inet  239.255.255.250
```
üß† **Comentario:**  
Tu interfaz `eth0` est√° suscrita a m√∫ltiples grupos multicast (como mDNS o SSDP).

#### üîß `netstat -g`

‚úÖ **Qu√© hace:**  
Muestra membres√≠as multicast activas a nivel de sistema.


```bash
IPv4 Multicast Group Memberships
Interface       RefCnt Group
--------------- ------ ---------------------
eth0            1      224.0.0.1
eth0            1      239.255.255.250
```
üß† **Comentario:**  
Aqu√≠ ves qu√© grupos est√°n activos y en qu√© interfaz.

---
#### üîß `tcpdump igmp`

‚úÖ **Qu√© hace:**  
Captura mensajes IGMP en tiempo real (Membership Report, Leave, etc.).

```bash
IP 192.168.1.45 > 224.0.0.1: igmp query v2
IP 192.168.1.45 > 224.0.0.251: igmp report v2
```

üß† **Comentario:**  
Puedes ver cu√°ndo tu sistema se une o deja un grupo multicast, o responde a queries de un router.

---

#### üîß `ping 224.0.0.1`

‚úÖ **Qu√© hace:**  
Env√≠a ICMP multicast a todos los hosts que escuchen ese grupo.

```bash
64 bytes from 192.168.1.34: icmp_seq=1 ttl=1 time=1.9 ms
``` 

üß† **Comentario:**  
Ves qu√© otros hosts en tu red responden a solicitudes multicast.

---

## üìò Cap√≠tulo 14: DNS ‚Äì Domain Name System

### üß† Lo esencial que debes saber

- **DNS** (Domain Name System) es el sistema encargado de **resolver nombres de dominio (como google.com) en direcciones IP** (como 142.250.190.14).
- Es fundamental en toda comunicaci√≥n de red: sin DNS, necesitar√≠as recordar IPs en lugar de nombres.
- DNS utiliza generalmente **UDP puerto 53**, aunque puede usar TCP para respuestas grandes o transferencia de zonas.
- Es una arquitectura distribuida, jer√°rquica y en forma de √°rbol.

---

### üß© C√≥mo funciona una consulta DNS

1. El cliente pregunta a su **servidor DNS configurado localmente** (generalmente un router o 8.8.8.8).
2. Si ese servidor no tiene la respuesta en cach√©, realiza una **consulta recursiva**:
   - Contacta a los **root servers** ‚Üí `.`
   - Luego a los **servidores TLD** ‚Üí `.com`
   - Luego al **servidor autoritativo** ‚Üí `example.com`
3. La IP final se devuelve al cliente, que puede entonces hacer su conexi√≥n (ej. HTTP, SMTP...).

---

### üì¶ Tipos comunes de registros DNS

| Tipo  | Descripci√≥n                                      |
|-------|--------------------------------------------------|
| A     | Direcci√≥n IPv4                                   |
| AAAA  | Direcci√≥n IPv6                                   |
| CNAME | Alias de otro dominio                            |
| MX    | Servidor de correo                               |
| NS    | Nameserver autorizado                            |
| PTR   | Resoluci√≥n inversa (IP ‚Üí nombre)                 |
| TXT   | Informaci√≥n arbitraria (SPF, verificaci√≥n, etc.) |

---

### üë®‚Äçüíª Relevancia para backend

- Toda comunicaci√≥n entre servicios **usar√° DNS**, ya sea dentro o fuera del cl√∫ster o red.
- Muchos errores en apps backend se deben a:
  - **Timeouts DNS**
  - **Resoluci√≥n incorrecta**
  - **Cambios de IP sin actualizaci√≥n de cach√©**
- DNS mal configurado en contenedores, Kubernetes, o VPNs puede romper microservicios.
- Puedes usar DNS para:
  - Balanceo de carga b√°sico
  - Alta disponibilidad (fallbacks)
  - Discovery din√°mico

---

## üõ†Ô∏è Comandos / herramientas √∫tiles

| Comando / Herramienta            | Funci√≥n                                                               |
|----------------------------------|-----------------------------------------------------------------------|
| `dig <dominio>`                  | Consulta DNS detallada (muy completa)                                 |
| `nslookup <dominio>`            | Consulta b√°sica de nombre a IP                                        |
| `host <dominio>`                 | Consulta simple, salida compacta                                      |
| `ping <dominio>`                 | Prueba conectividad y resoluci√≥n                                      |
| `resolvectl status` / `systemd-resolve` | Ver el DNS configurado actualmente en sistemas modernos         |
| `tcpdump port 53`               | Captura tr√°fico DNS                                                   |

---

### üß™ Ejemplos pr√°cticos

---

#### üîß `dig openai.com`

‚úÖ **Qu√© hace:**  
Consulta DNS al servidor configurado y muestra toda la informaci√≥n.

```bash
; <<>> DiG 9.16.1 <<>> openai.com
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 12345
;; QUESTION SECTION:
;openai.com.            IN    A

;; ANSWER SECTION:
openai.com.     299     IN    A    104.18.12.123
```
üß† **Comentario:**  
`dig` da detalles √∫tiles: TTL, tipo de registro, autoridad, etc. Ideal para depurar.


#### üîß `nslookup google.com`

‚úÖ **Qu√© hace:**  Consulta r√°pida y f√°cil, √∫til en casi cualquier sistema.

```bash
Server:  192.168.1.1
Address: 192.168.1.1#53 Non-authoritative answer:
Name: google.com
Address: 142.250.190.14
``` 

üß† **Comentario:**  Menos detallado que `dig`, pero r√°pido y disponible incluso en Windows.

#### üîß `host github.com`

‚úÖ **Qu√© hace:**  
Consulta DNS con salida concisa.

```bash
github.com has address 140.82.114.4
``` 

üß† **Comentario:**  
Perfecto para scripts o verificaciones r√°pidas.

----------

#### üîß `ping openai.com`

‚úÖ **Qu√© hace:**  
Hace una consulta DNS y luego intenta conectar por ICMP.

```bash
PING openai.com (104.18.12.123): 56 data bytes
64 bytes from 104.18.12.123: icmp_seq=0 ttl=57 time=12.3 ms
``` 

üß† **Comentario:**  
Confirmas que el dominio resuelve y es accesible.

----------

#### üîß `resolvectl status`

‚úÖ **Qu√© hace:**  
Muestra qu√© servidores DNS est√° usando tu sistema actualmente (Linux + systemd).

```bash
Current DNS Server: 192.168.1.1
DNS Servers: 192.168.1.1
DNSSEC supported: yes
``` 

üß† **Comentario:**  
√ötil para ver si est√°s usando el DNS de la red, uno externo como 8.8.8.8 o uno local.


## üìò Cap√≠tulo 15: TFTP ‚Äì Trivial File Transfer Protocol

### üß† Lo esencial que debes saber

- **TFTP** es un protocolo de transferencia de archivos **muy simple**, dise√±ado para sistemas **ligeros o embebidos**.
- Funciona sobre **UDP (puerto 69)**, lo que lo hace r√°pido pero sin fiabilidad incorporada como TCP.
- Fue dise√±ado para:
  - **Cargar firmware o sistemas operativos** (ej. por red en dispositivos sin disco)
  - **Transferencias sencillas sin autenticaci√≥n**
- Es un protocolo **sin estado** y muy limitado.

---

### üì¶ Caracter√≠sticas clave de TFTP

| Caracter√≠stica      | Descripci√≥n                                               |
|---------------------|-----------------------------------------------------------|
| Protocolo base      | UDP (puerto 69)                                           |
| Seguridad           | No tiene autenticaci√≥n ni cifrado                         |
| Fiabilidad          | Requiere ACKs y reintentos manuales                       |
| Uso principal       | Boot por red (PXE), dispositivos embebidos, routers       |
| Comandos soportados | RRQ (read), WRQ (write), DATA, ACK, ERROR                 |

üß† **Importante:** Debido a su simplicidad y falta de seguridad, **TFTP solo se recomienda en redes internas controladas.**

---

### üë®‚Äçüíª Relevancia para backend

- No se usa directamente en backend moderno, pero **puede estar presente en entornos industriales, IoT, routers o BIOS PXE boot**.
- Si trabajas cerca del hardware, firmware, arranque de red o sistemas embebidos, **te cruzar√°s con TFTP**.
- Es √∫til para:
  - **Cargar configuraciones o firmware**
  - Depurar cargas PXE que fallan

---

### üõ†Ô∏è Comandos / herramientas √∫tiles

| Herramienta / Comando       | Funci√≥n                                                        |
|-----------------------------|-----------------------------------------------------------------|
| `tftp <host>`               | Cliente TFTP interactivo                                       |
| `tftp -g -r <archivo> <host>` | Descarga (`get`) un archivo desde un servidor TFTP            |
| `tftp -p -l <archivo> <host>` | Sube (`put`) un archivo a un servidor TFTP                    |
| `tcpdump port 69`           | Captura tr√°fico TFTP                                           |
| `atftpd`, `tftpd-hpa`       | Servidores TFTP en Linux                                       |

---

### üß™ Ejemplos pr√°cticos

---

#### üîß `tftp 192.168.1.100`

‚úÖ **Qu√© hace:**  Inicia una sesi√≥n interactiva TFTP con el host.

```bash
tftp> get firmware.bin
Received 245760 bytes in 2.0 seconds
tftp> quit
```
üß† **Comentario:**  
Descarga de archivo desde un servidor TFTP local, sin autenticaci√≥n ni cifrado.

#### üîß `tftp -g -r config.txt 192.168.1.100`

‚úÖ **Qu√© hace:**  
Descarga el archivo `config.txt` del servidor `192.168.1.100`.

`config.txt received successfully` 

üß† **Comentario:**  
Opci√≥n muy usada en scripts o procesos autom√°ticos de configuraci√≥n.


#### üîß `tftp -p -l init.cfg 192.168.1.100`

‚úÖ **Qu√© hace:**  Sube el archivo `init.cfg` al servidor TFTP.

`Sent 3 blocks, 512 bytes per block` 

üß† **Comentario:**  
No hay control de acceso, as√≠ que es importante **no usarlo en redes abiertas**.

----------

#### üîß `tcpdump port 69`

‚úÖ **Qu√© hace:**  
Captura el tr√°fico TFTP (UDP puerto 69).

`192.168.1.45.43256 > 192.168.1.100.69:  25 RRQ "firmware.bin" octet
192.168.1.100.69 > 192.168.1.45.43256: DATA block 1 (512 bytes)` 

üß† **Comentario:**  
Muy √∫til para verificar si la transferencia se inicia correctamente.


## üìò Cap√≠tulo 16: BOOTP ‚Äì Bootstrap Protocol

### üß† Lo esencial que debes saber

- **BOOTP (Bootstrap Protocol)** permite que un dispositivo sin disco (o sin configuraci√≥n IP) obtenga autom√°ticamente:
  - Su direcci√≥n IP
  - La direcci√≥n de su servidor de arranque
  - La ubicaci√≥n de un archivo de arranque (ej. para cargar v√≠a TFTP)

- BOOTP fue dise√±ado para equipos que arrancan por red y **no tienen almacenamiento persistente**.

- Usa **UDP**:
  - Cliente ‚Üí Servidor: puerto 67
  - Servidor ‚Üí Cliente: puerto 68

---

### üì¶ Caracter√≠sticas principales

| Caracter√≠stica      | Valor                                 |
|---------------------|----------------------------------------|
| Protocolo base      | UDP (67/68)                            |
| M√©todo de asignaci√≥n| Manual (basado en la MAC del cliente)  |
| Funci√≥n clave       | Proveer IP y par√°metros de arranque    |
| Respuesta esperada  | IP, gateway, servidor TFTP, ruta del archivo de arranque |

üß† **Importante:** BOOTP fue el precursor de **DHCP**, que lo reemplaz√≥ al a√±adir asignaci√≥n din√°mica y m√°s opciones.

---

### üë®‚Äçüíª Relevancia para backend

- Aunque **ya casi no se usa en entornos modernos**, BOOTP puede estar presente en:
  - Entornos industriales / IoT antiguos
  - Arranque de red (PXE boot)
  - Laboratorios de virtualizaci√≥n o BIOS legacy

- Si trabajas en:
  - Automatizaci√≥n de sistemas base
  - Dispositivos embebidos
  - Provisionamiento de hardware desde cero

  ...entender BOOTP te ayudar√° a **interpretar arranques por red y logs tempranos**.

---

### üõ†Ô∏è Comandos / herramientas √∫tiles

| Herramienta / Comando       | Funci√≥n                                                       |
|-----------------------------|----------------------------------------------------------------|
| `tcpdump port 67 or port 68`| Captura tr√°fico BOOTP/DHCP                                     |
| `dnsmasq` / `isc-dhcp-server`| Pueden actuar como servidores BOOTP (con opci√≥n TFTP)         |
| `pxelinux.0` / `bootfile`   | Archivo de arranque que se entrega junto con BOOTP            |
| `tftp`                      | BOOTP suele usarse junto con TFTP para transferir archivos     |

---

### üß™ Ejemplos pr√°cticos

#### üîß `tcpdump port 67 or port 68`

‚úÖ **Qu√© hace:**  Captura mensajes BOOTP en la red.

```bash
IP 0.0.0.0.68 > 255.255.255.255.67: BOOTP/DHCP, Request from 08:00:27:12:34:56
IP 192.168.1.1.67 > 192.168.1.10.68: BOOTP/DHCP, Reply, IP 192.168.1.10
```
üß† **Comentario:**  
El cliente no tiene IP, as√≠ que env√≠a desde `0.0.0.0` a broadcast. El servidor le asigna una IP v√°lida.

#### üîß Configuraci√≥n de `dnsmasq` para BOOTP

‚úÖ **Qu√© hace:**  Act√∫a como servidor BOOTP + TFTP.

```bash
dhcp-boot=pxelinux.0
enable-tftp
tftp-root=/srv/tftp
``` 

üß† **Comentario:**  
Con esta configuraci√≥n, `dnsmasq` responde a solicitudes BOOTP y ofrece el archivo de arranque `pxelinux.0` por TFTP.


#### üîß Respuesta BOOTP t√≠pica

```bash
Your IP: 192.168.1.50
Server IP: 192.168.1.1
Bootfile: pxelinux.0
Next server: 192.168.1.1
``` 

üß† **Comentario:**  
El cliente ahora puede descargar el archivo de arranque desde el servidor especificado.

#### üîß Archivo de arranque por TFTP (`pxelinux.0`)

‚úÖ **Qu√© hace:**  BOOTP solo dice d√≥nde est√° el archivo, pero **TFTP lo transfiere**.

```bash
192.168.1.50.12345 > 192.168.1.1.69: 25 RRQ "pxelinux.0" octet
``` 

üß† **Comentario:**  
Esta es la siguiente etapa tras recibir la IP y el archivo de arranque. BOOTP + TFTP = PXE boot funcional.

## üìò Cap√≠tulo 17: TCP ‚Äì Transmission Control Protocol

### üß† Lo esencial que debes saber
- **TCP** es un protocolo de transporte confiable, orientado a conexi√≥n.
- Garantiza:
  - Entrega **sin errores**
  - Entrega **en orden**
  - **Evita duplicados**
- Se usa para la mayor√≠a de aplicaciones backend: **HTTP(S), SMTP, FTP, SSH, SQL, etc.**
- Opera sobre IP, pero a√±ade:
  - Control de flujo
  - Retransmisiones
  - Confirmaciones (ACK)
  - Control de congesti√≥n

---

### üì¶ Cabecera TCP (campos importantes)

| Campo             | Descripci√≥n                                      |
|------------------|--------------------------------------------------|
| Source Port      | Puerto de origen                                 |
| Destination Port | Puerto de destino                                |
| Sequence Number  | N√∫mero de secuencia del primer byte              |
| Acknowledgment # | Confirma recepci√≥n de bytes anteriores           |
| Flags            | Control de la conexi√≥n: SYN, ACK, FIN, RST...    |
| Window Size      | Control de flujo: cu√°ntos bytes puede recibir    |
| Checksum         | Verificaci√≥n de errores                          |

---

### üîÅ C√≥mo funciona una conexi√≥n TCP

1. **Three-way handshake**:
   - Cliente env√≠a `SYN`
   - Servidor responde `SYN-ACK`
   - Cliente responde `ACK`
2. Luego los datos se intercambian en segmentos.
3. La conexi√≥n se cierra con `FIN` / `ACK`.

üß† TCP **mantiene estado** en ambos extremos de la conexi√≥n.

---

### üë®‚Äçüíª Relevancia para backend

- Casi todo backend moderno se basa en TCP:
  - APIs REST, servicios gRPC, bases de datos, microservicios
- Conocer TCP ayuda a:
  - **Diagnosticar timeouts y ca√≠das de conexi√≥n**
  - Saber si tu servicio est√° saturado (ventana TCP llena)
  - Entender el efecto de la **latencia y p√©rdida de paquetes**
  - Optimizar **sockets** y conexiones en apps de alto rendimiento

---

### üõ†Ô∏è Comandos / herramientas √∫tiles

| Herramienta / Comando         | Funci√≥n                                                                 |
|-------------------------------|-------------------------------------------------------------------------|
| `ss -t -a`                    | Ver conexiones TCP activas                                             |
| `netstat -tn`                 | Ver conexiones TCP sin resoluci√≥n DNS                                 |
| `tcpdump tcp`                 | Capturar tr√°fico TCP                                                   |
| `telnet <host> <puerto>`      | Probar conexi√≥n TCP simple                                             |
| `curl -v` / `nc`              | Ver detalles de conexi√≥n (handshake, headers, etc.)                   |

---

### üß™ Ejemplos pr√°cticos

#### üîß `ss -t -a`

‚úÖ **Qu√© hace:**  Muestra todas las conexiones TCP abiertas o en escucha.

```bash
State      Recv-Q Send-Q Local Address:Port   Peer Address:Port
LISTEN     0      128    0.0.0.0:80           0.0.0.0:*
ESTAB      0      0      192.168.1.50:22      192.168.1.30:53200
```
üß† **Comentario:**  Puedes ver servicios escuchando (ej. HTTP, SSH) y sesiones establecidas.


#### üîß `tcpdump tcp port 80`

‚úÖ **Qu√© hace:**  Captura tr√°fico HTTP (TCP puerto 80).

`IP 192.168.1.50.53200 > 93.184.216.34.80: Flags [S], seq 0, win 64240` 

üß† **Comentario:**  Aqu√≠ empieza una conexi√≥n TCP con `SYN`. Puedes seguir el handshake completo si capturas m√°s tr√°fico.

----------

#### üîß `telnet example.com 80`

‚úÖ **Qu√© hace:**  Inicia una conexi√≥n TCP a un puerto (como HTTP).

```bash
Trying 93.184.216.34...
Connected to example.com.
``` 

üß† **Comentario:**  √ötil para comprobar si un puerto TCP est√° accesible (aunque el protocolo no sea Telnet).

----------

#### üîß `curl -v http://example.com`

‚úÖ **Qu√© hace:**  Muestra el proceso de conexi√≥n TCP + petici√≥n HTTP.

```bash
*   Trying 93.184.216.34:80...
* Connected to example.com
> GET / HTTP/1.1
> Host: example.com
``` 

üß† **Comentario:**  
Combina visibilidad de TCP + HTTP. Muy √∫til para backend.

----------

#### üîß `netstat -tn`

‚úÖ **Qu√© hace:**  Muestra conexiones TCP activas sin resolver DNS.

`tcp        0      0 192.168.1.50:54321   93.184.216.34:443   ESTABLISHED` 

üß† **Comentario:**  Ideal para ver conexiones reales en producci√≥n o contenedores sin overhead de resoluci√≥n.


## üìò Cap√≠tulo 18: TCP Connection Establishment ‚Äì Three-Way Handshake

### üß† Lo esencial que debes saber

- El establecimiento de una conexi√≥n TCP se realiza mediante el **three-way handshake** ("apret√≥n de manos en tres pasos").
- Este mecanismo permite:
  - Confirmar que ambos extremos est√°n vivos
  - Sincronizar n√∫meros de secuencia
  - Preparar el canal confiable para intercambiar datos

---

### üîÅ Proceso del three-way handshake

| Paso | Cliente                | Servidor                     |
|------|------------------------|------------------------------|
| 1    | Env√≠a `SYN`            |                              |
| 2    |                        | Recibe `SYN`, responde `SYN-ACK` |
| 3    | Recibe `SYN-ACK`, responde `ACK` | Servidor recibe `ACK` |

üß† **Resultado:**  
Ambos extremos conocen los n√∫meros de secuencia y est√°n listos para enviar datos.

---

### üì¶ Campos relevantes en la cabecera TCP

| Campo            | Funci√≥n                                         |
|------------------|--------------------------------------------------|
| `SYN`            | Solicita conexi√≥n e inicia secuencia            |
| `ACK`            | Confirma recepci√≥n de datos o solicitud         |
| `Sequence Number`| N√∫mero inicial elegido aleatoriamente           |
| `Window`         | Tama√±o de ventana (control de flujo)            |

---

### üîÑ Ejemplo de secuencia (simplificada)

```bash
Cliente ‚Üí Servidor: SYN, Seq=100
Servidor ‚Üí Cliente: SYN-ACK, Seq=200, Ack=101
Cliente ‚Üí Servidor: ACK, Seq=101, Ack=201
```

### üë®‚Äçüíª Relevancia para backend

-   Entender el handshake es clave para:
    
    -   Diagnosticar **latencia en el establecimiento de conexi√≥n**
        
    -   Detectar **conexiones a medio abrir (SYN flood)**
        
    -   Depurar problemas de servicios que **no responden a conexiones entrantes**
        
-   Las herramientas de observabilidad y firewalls **pueden filtrar conexiones SYN** maliciosas.

### üõ†Ô∏è Comandos / herramientas √∫tiles

| Comando / Herramienta                                | Funci√≥n                                                                 |
|------------------------------------------------------|-------------------------------------------------------------------------|
| `tcpdump 'tcp[tcpflags] & tcp-syn != 0'`             | Captura paquetes TCP con flag SYN (inicio de conexi√≥n)                 |
| `ss -t state syn-recv`                               | Muestra conexiones en estado `SYN-RECV` (esperando √∫ltimo ACK)         |
| `netstat -nat`                                       | Lista conexiones TCP con sus estados (LISTEN, SYN_SENT, etc.)          |
| `iptables -A INPUT -p tcp --syn -j ACCEPT`           | Permite expl√≠citamente paquetes SYN entrantes                          |
| `ufw allow proto tcp from any to any port 80`        | Permite conexiones TCP entrantes al puerto 80 (usando UFW)             |



### üß™ Ejemplos pr√°cticos

----------

#### üîß `tcpdump 'tcp[tcpflags] & (tcp-syn) != 0'`

‚úÖ **Qu√© hace:**  
Muestra todos los paquetes que contienen el flag `SYN`.

bash

Copiar

`IP 192.168.1.100.54321 > 93.184.216.34.443: Flags [S], seq 0, win 64240` 

üß† **Comentario:**  
Captura el primer paso del handshake TCP. Ideal para comprobar si un cliente intenta conectarse.

----------

#### üîß `ss -t state syn-recv`

‚úÖ **Qu√© hace:**  
Muestra conexiones TCP que est√°n **esperando el ACK final del cliente**.

```bash
Recv-Q Send-Q Local Address:Port Peer Address:Port
0      0      192.168.1.80:443     192.168.1.50:56234
``` 

üß† **Comentario:**  Un ataque SYN flood dejar√≠a muchas conexiones aqu√≠ sin completarse.

----------

#### üîß `netstat -nat`

‚úÖ **Qu√© hace:**  Muestra todas las conexiones TCP con su estado.


```bash
tcp  0  0 0.0.0.0:443  0.0.0.0:*  LISTEN
tcp  0  0 192.168.1.80:443  192.168.1.50:56234  ESTABLISHED
``` 

üß† **Comentario:**  
Puedes ver conexiones establecidas o en proceso de establecimiento.




## üìò Cap√≠tulo 11: tcpdump ‚Äì Herramienta de captura de paquetes

### üß† Lo esencial que debes saber

- `tcpdump` es una herramienta de l√≠nea de comandos para **capturar y analizar paquetes** de red en tiempo real.
- Te permite observar el tr√°fico **desde y hacia tu m√°quina** en diferentes capas: IP, TCP, UDP, ICMP, ARP, etc.
- Es extremadamente √∫til para:
  - Depurar problemas de red
  - Ver qu√© paquetes est√°n saliendo o entrando en tu app
  - Analizar protocolos (DNS, HTTP, TLS‚Ä¶)

---

### üîç ¬øQu√© puede mostrarte tcpdump?

- Direcciones IP de origen y destino
- Puertos de aplicaci√≥n (ej. 443, 80)
- Flags TCP (SYN, ACK, FIN‚Ä¶)
- Protocolos usados (ICMP, DNS, TLS, etc.)
- Tramas ARP o solicitudes DHCP
- Payload (contenido del paquete) si se desea

---

### üë®‚Äçüíª Relevancia para backend

- Ideal para ver si tu **servicio est√° recibiendo peticiones** o si hay **errores de red (timeouts, p√©rdidas)**.
- Puedes observar si una app realmente est√° haciendo requests (p. ej., microservicios, llamadas HTTP).
- Es crucial en debugging de **conectividad, DNS, SSL/TLS**, o incluso ataques de red.

---

### üõ†Ô∏è Comandos / opciones √∫tiles

| Comando                                | Descripci√≥n                                                           |
|----------------------------------------|-----------------------------------------------------------------------|
| `sudo tcpdump -i <iface>`              | Captura todo el tr√°fico de la interfaz                               |
| `sudo tcpdump -n`                      | No resuelve nombres DNS ni de puertos (m√°s r√°pido)                   |
| `sudo tcpdump port 80`                 | Solo tr√°fico HTTP (puerto 80)                                        |
| `sudo tcpdump tcp`                     | Solo tr√°fico TCP                                                     |
| `sudo tcpdump -X port 80`              | Muestra tambi√©n el contenido (payload) de cada paquete HTTP          |
| `sudo tcpdump -i lo`                   | Captura tr√°fico entre procesos locales (loopback)                    |

---

### üß™ Ejemplos pr√°cticos

#### üîß `sudo tcpdump -i eth0`

‚úÖ **Qu√© hace:**  Muestra todo el tr√°fico de la interfaz de red principal (`eth0`).

üì§ **Salida t√≠pica:**
```bash
IP 192.168.1.45.54321 > 93.184.216.34.443: Flags [S], seq 0, win 29200, length 0
```

üß† **Comentario:**  
Un paquete TCP saliendo hacia el puerto 443 (HTTPS). Puedes ver flags como `S` (SYN), `P` (Push), `F` (FIN), etc.

---

### üîß `sudo tcpdump port 53`

‚úÖ **Qu√© hace:**  Filtra solo el tr√°fico DNS (puerto 53).

üì§ **Salida t√≠pica:**
```bash
IP 192.168.1.45.53536 > 8.8.8.8.53: 12345+ A? google.com. (28)
```

üß† **Comentario:**  
Muestra una solicitud DNS preguntando por la IP de `google.com`.

---

### üîß `sudo tcpdump -X port 80`

‚úÖ **Qu√© hace:**  Muestra tr√°fico HTTP con el contenido del paquete en formato hexadecimal + ASCII.

üì§ **Salida t√≠pica:**
```bash
GET / HTTP/1.1 Host: example.com User-Agent: curl/7.68.0
```

üß† **Comentario:**  
Perfecto para ver qu√© datos env√≠a tu app al servidor (headers, cuerpo de petici√≥n, etc.).

---

### üîß `sudo tcpdump -n -i lo`

‚úÖ **Qu√© hace:**  Muestra tr√°fico en la interfaz loopback (`localhost`), sin resolver nombres de dominio o puertos.

üì§ **Salida t√≠pica:**
```bash
IP 127.0.0.1.5000 > 127.0.0.1.8080: Flags [P.], length 64
```

üß† **Comentario:**  
√ötil cuando est√°s debugueando microservicios que se comunican entre s√≠ en tu propio sistema.

---

### üîß `sudo tcpdump -i eth0 icmp`

‚úÖ **Qu√© hace:**  Filtra tr√°fico ICMP (como ping o traceroute).

üì§ **Salida t√≠pica:**
```bash
IP 192.168.1.45 > 8.8.8.8: ICMP echo request, id 12345, seq 1 IP 8.8.8.8 > 192.168.1.45: ICMP echo reply, id 12345, seq 1
```

üß† **Comentario:**  Muy √∫til para depurar conectividad b√°sica y respuestas a `ping`.

---

## üìò Cap√≠tulo 20: TCP ‚Äì Bulk Data Flow

### üß† Lo esencial que debes saber

- Este cap√≠tulo analiza c√≥mo TCP gestiona **transferencias de datos grandes** (bulk transfers), como:
  - Descarga de archivos grandes
  - Transferencia de bases de datos
  - Streams multimedia de gran tama√±o
- A diferencia de flujos interactivos, aqu√≠ lo importante es **eficiencia y rendimiento**, m√°s que latencia inmediata.

---

### ‚öôÔ∏è Mecanismos clave en flujo de datos grandes

| Mecanismo             | Descripci√≥n                                                                 |
|------------------------|-----------------------------------------------------------------------------|
| **Ventana de recepci√≥n (rwnd)** | Cu√°ntos bytes puede recibir el host destino sin desbordar su buffer  |
| **Ventana de congesti√≥n (cwnd)**| TCP limita la cantidad de datos enviados para evitar congesti√≥n      |
| **Slow Start**         | TCP comienza con una ventana peque√±a y la incrementa exponencialmente      |
| **Retransmisi√≥n r√°pida**| Reenv√≠a paquetes perdidos sin esperar el timeout completo (si recibe 3 ACKs duplicados) |
| **TCP Flow Control**   | Controla el ritmo de env√≠o seg√∫n capacidad del receptor                    |
| **TCP Congestion Control** | Controla el ritmo seg√∫n el estado de la red                            |

---

### üîÅ Flujo t√≠pico de una transferencia grande

1. Se establece conexi√≥n (3-way handshake)
2. TCP empieza con **slow start**
3. A medida que no hay p√©rdidas, aumenta la ventana (m√°s rendimiento)
4. Si detecta congesti√≥n ‚Üí reduce velocidad y se recupera

üß† TCP **se adapta din√°micamente** a las condiciones de la red y del receptor.

---

### üë®‚Äçüíª Relevancia para backend

- Afecta directamente a:
  - APIs que **descargan o suben archivos grandes**
  - **Backups y restauraciones** por red
  - **Bases de datos distribuidas**
  - Comunicaci√≥n entre microservicios que comparten datos masivos

- Problemas t√≠picos:
  - **P√©rdidas de paquetes** ‚Üí bajada dr√°stica de cwnd
  - Mala configuraci√≥n de buffers ‚Üí **rendimiento limitado**
  - **Firewalls o balanceadores** con timeout bajo ‚Üí cierre de conexiones largas

---

### üõ†Ô∏è Comandos / herramientas √∫tiles

| Comando / Herramienta                    | Funci√≥n                                                            |
|------------------------------------------|---------------------------------------------------------------------|
| `ss -t -i`                                | Ver par√°metros como cwnd, rtt, retransmisiones                     |
| `iperf3 -c <host>`                        | Medir rendimiento de TCP en bulk transfers                         |
| `tcpdump`                                 | Ver tama√±o de segmentos, retransmisiones, ACKs                     |
| `netstat -s`                              | Ver estad√≠sticas globales TCP, retransmisiones, congesti√≥n         |
| `sysctl -a | grep tcp_window_scaling`     | Ver si la escala de ventanas est√° activada (clave para alto rendimiento) |

---

### üß™ Ejemplos pr√°cticos

#### üîß `ss -t -i`

‚úÖ **Qu√© hace:**  
Muestra detalles t√©cnicos de conexiones TCP activas.

```bash
cwnd: 23, rtt: 34.5 ms, retrans: 1
```
üß† **Comentario:**  
El tama√±o de la ventana de congesti√≥n (`cwnd`) es clave en transferencias masivas. Cuanto m√°s alto, m√°s rendimiento.

#### üîß `iperf3 -c <servidor>`

‚úÖ **Qu√© hace:**  Testea el rendimiento de una conexi√≥n TCP con env√≠o sostenido.


```bash
[ ID] Interval           Transfer     Bandwidth
[  5]   0.00-10.00 sec  1.10 GBytes  944 Mbits/sec
``` 

üß† **Comentario:**  
Excelente para medir throughput real en bulk transfers (¬°√∫til en tuning de red!).

----------

#### üîß `tcpdump -i eth0 tcp`

‚úÖ **Qu√© hace:**  
Analiza si hay p√©rdidas o retransmisiones durante una descarga masiva.

```bash
IP ... Flags [P.], length 1448
IP ... Retransmission
``` 

üß† **Comentario:**  Puedes ver si hay paquetes perdidos, lo cual limita la velocidad por ca√≠da de cwnd.

----------

#### üîß `netstat -s`

‚úÖ **Qu√© hace:**  
Muestra estad√≠sticas del stack TCP.

```bash
4560 segments retransmitted
120 fast retransmits
``` 

üß† **Comentario:**  
Si hay muchas retransmisiones, hay p√©rdida de rendimiento. Puede que la red est√© saturada o inestable.

----------

#### üîß `sysctl net.ipv4.tcp_window_scaling`

‚úÖ **Qu√© hace:**  
Indica si tu sistema soporta ventanas grandes (para redes de alto rendimiento).

```bash
net.ipv4.tcp_window_scaling = 1
``` 

üß† **Comentario:**  
En redes modernas con alta latencia (como cloud + S3), sin esto activado **se limita el rendimiento** TCP.


## üìò Cap√≠tulo 21: TCP Timeout and Retransmission

### üß† Lo esencial que debes saber

- TCP garantiza la entrega de datos mediante un sistema de **retransmisi√≥n con temporizadores (timeouts)**.
- Si un paquete no es **confirmado (ACK)** dentro de cierto tiempo ‚Üí se **retransmite**.
- El temporizador **se ajusta din√°micamente** seg√∫n la latencia real (RTT).
- TCP tambi√©n aplica t√©cnicas para **detectar p√©rdidas m√°s r√°pidamente** que un simple timeout.

---

### üîÅ Proceso de retransmisi√≥n TCP

1. Se env√≠a un segmento.
2. Si no se recibe ACK antes del **RTO (Retransmission Timeout)** ‚Üí se retransmite.
3. TCP **duplica el RTO** en cada fallo (exponencial backoff).
4. Si se reciben **ACKs duplicados** ‚Üí se activa **Fast Retransmit** (antes del timeout).

---

### ‚öôÔ∏è Mecanismos involucrados

| Mecanismo             | Descripci√≥n                                                                 |
|------------------------|-----------------------------------------------------------------------------|
| **RTO (Retransmission Timeout)** | Tiempo m√°ximo esperado para el ACK de un paquete                   |
| **RTT (Round-Trip Time)**        | Tiempo real de ida y vuelta, medido din√°micamente                 |
| **Fast Retransmit**              | Si se reciben 3 ACKs duplicados, se considera p√©rdida inmediata    |
| **Exponential Backoff**          | Cada retransmisi√≥n duplica el RTO ‚Üí evita saturar la red          |
| **SACK (Selective Acknowledgment)** | Permite al receptor informar de qu√© bloques recibi√≥               |

---

### üë®‚Äçüíª Relevancia para backend

- Ayuda a entender:
  - Por qu√© algunas peticiones **parecen congelarse** ‚Üí retransmisiones ocultas
  - Por qu√© una conexi√≥n **no se rompe inmediatamente** ante fallo ‚Üí espera de timeout
  - Por qu√© **microservicios pueden experimentar retrasos espor√°dicos** en redes inestables
- Algunas **librer√≠as o proxies** pueden aplicar timeouts m√°s agresivos que TCP ‚Üí diferencias entre comportamiento de red y app

---

### üõ†Ô∏è Comandos / herramientas √∫tiles

| Comando / Herramienta            | Funci√≥n                                                             |
|----------------------------------|----------------------------------------------------------------------|
| `ss -ti`                         | Ver informaci√≥n de conexiones, incluido RTO y retransmisiones       |
| `netstat -s`                     | Ver estad√≠sticas de retransmisiones y timeouts                      |
| `tcpdump tcp`                    | Ver retransmisiones reales y ACKs duplicados                        |
| `iperf3 --retrans`               | Ver tasa de retransmisi√≥n bajo carga                                |
| `sysctl net.ipv4.tcp_retries2`   | Cambiar cu√°nto espera TCP antes de cerrar una conexi√≥n rota         |

---

### üß™ Ejemplos pr√°cticos

#### üîß `ss -ti`

‚úÖ **Qu√© hace:**  
Muestra detalles t√©cnicos de las conexiones TCP, incluyendo retransmisiones.

```bash
cwnd: 10, rtt: 45.6 ms, rto: 200ms, retrans: 1
```

üß† **Comentario:**  
RTO indica cu√°nto espera TCP antes de retransmitir. Si hay retransmisiones frecuentes, podr√≠a haber congesti√≥n o p√©rdida.

---

### üîß `netstat -s`

‚úÖ **Qu√© hace:**  Muestra estad√≠sticas acumuladas de TCP.

`450 segments retransmitted
120 connections reset due to timeout` 

üß† **Comentario:**  
Te da una visi√≥n general del comportamiento de TCP en el sistema. Buena herramienta de diagn√≥stico global.

----------

#### üîß `tcpdump 'tcp[13] & 0x10 != 0'`

‚úÖ **Qu√© hace:**  Captura segmentos con el flag ACK, √∫tiles para analizar duplicados.

```bash
IP ... ack 3001 win 512
IP ... ack 3001 win 512
IP ... ack 3001 win 512  ‚Üê ACK duplicados
``` 

üß† **Comentario:**  Si ves m√∫ltiples ACKs iguales ‚Üí podr√≠a activarse **Fast Retransmit**.

----------

#### üîß `iperf3 --retrans` (modo servidor)

‚úÖ **Qu√© hace:**  
Mide retransmisiones durante un test de rendimiento.

```bash
[ ID] Interval  Transfer   Bandwidth   Retr
[  4] 0.0-10.0s  1.0 GBytes  850 Mbits/s  32
``` 

üß† **Comentario:**  
Si hay muchos `Retr`, tu red o el stack TCP est√°n teniendo problemas. √ötil para tuning.

----------

#### üîß `sysctl net.ipv4.tcp_retries2`

‚úÖ **Qu√© hace:**  
Controla cu√°ntos reintentos hace TCP antes de **cerrar** la conexi√≥n (por defecto: 15 ‚Üí ~13 minutos).

`net.ipv4.tcp_retries2 = 15` 

üß† **Comentario:**  
Si tienes servicios que tardan en caer o colgar conexiones, puedes reducir esto para cerrar m√°s r√°pido.



## üìò Cap√≠tulo 22: TCP Persist Timer

### üß† Lo esencial que debes saber

- El **persist timer** de TCP se activa cuando el receptor **anuncia una ventana de recepci√≥n de 0 bytes (rwnd = 0)**.
- Esto significa que **el receptor no puede aceptar m√°s datos**, as√≠ que el emisor **debe detener el env√≠o**.

üß† Pero‚Ä¶ si el receptor **olvida avisar** cuando vuelve a tener espacio ‚Üí la conexi√≥n quedar√≠a congelada indefinidamente.

‚û°Ô∏è Para evitar esto, TCP usa el **persist timer**, que:
- Fuerza al emisor a enviar peque√±os paquetes ("probes") de vez en cuando.
- As√≠ el receptor puede notificar si **ya tiene espacio disponible** en su buffer.

---

### üîÅ Flujo de uso del persist timer

1. El receptor env√≠a un ACK con **ventana cero (rwnd = 0)**.
2. El emisor **detiene el env√≠o de datos**.
3. Se activa el **persist timer**.
4. Cuando el timer expira, el emisor env√≠a un **probe** (un byte no v√°lido).
5. El receptor responde con su nueva **ventana de recepci√≥n**.
6. Si rwnd > 0, el env√≠o se reanuda.

---

### üõë ¬øEn qu√© se diferencia de otros timers?

| Timer             | Funci√≥n                                                                 |
|-------------------|-------------------------------------------------------------------------|
| **RTO (Retransmission Timeout)** | Retransmitir si no hay ACK                                 |
| **Keepalive**      | Detectar si la conexi√≥n a√∫n est√° viva (inactiva)                        |
| **Persist Timer**  | Detectar si la **ventana cero sigue siendo cero**                      |

üß† El persist timer **mantiene viva la conexi√≥n y previene deadlocks** en presencia de ventanas 0.

---

### üë®‚Äçüíª Relevancia para backend

- Ayuda a evitar **bloqueos silenciosos** cuando un cliente no lee datos del socket.
- Es √∫til para detectar:
  - Servicios que se ‚Äúcuelan‚Äù pero no cierran la conexi√≥n
  - Clientes que no procesan datos pero mantienen la sesi√≥n abierta
- Especialmente relevante en:
  - **Bases de datos**
  - **WebSockets**
  - **Sistemas de streaming**

---

## üõ†Ô∏è Comandos / herramientas √∫tiles

| Comando / Herramienta           | Funci√≥n                                                                 |
|---------------------------------|--------------------------------------------------------------------------|
| `ss -i`                         | Ver detalles como la ventana de recepci√≥n (`rcv_wnd`)                   |
| `tcpdump`                       | Captura paquetes ACK con rwnd = 0 y probes TCP                          |
| `netstat -s`                    | Estad√≠sticas de ventanas cero                                           |
| `strace` / `lsof`               | Ver si una app est√° bloqueada esperando escribir en un socket lleno     |
| `sysctl net.ipv4.tcp_keepalive_time` | No controla el persist, pero puede ayudar a forzar detecci√≥n de conexiones muertas |

---

### üß™ Ejemplos pr√°cticos

---

#### üîß `ss -i`

‚úÖ **Qu√© hace:**  
Muestra el estado de las conexiones TCP, incluidas las ventanas.

```bash
rcv_wnd: 0, snd_wnd: 20480
```
üß† **Comentario:**  
Si `rcv_wnd` est√° a cero, se ha activado el persist timer. El emisor no puede enviar m√°s hasta que se reciba un update.


#### üîß `tcpdump 'tcp[13] & 0x10 != 0' and tcp[14:2] = 0'`

‚úÖ **Qu√© hace:**  Captura ACKs con ventana cero.

`IP 192.168.1.10.443 > 192.168.1.50.51234: Flags [ACK], win 0` 

üß† **Comentario:**  Indica que el receptor **no puede aceptar m√°s datos**. Si esto persiste, puede congelar el flujo.

---

#### üîß `netstat -s | grep 'zero window'`

‚úÖ **Qu√© hace:**  Muestra cu√°ntas veces se ha detectado una ventana cero.

`38 connections with persist probes
15 zero window probes sent` 

üß† **Comentario:**  
Ideal para saber si tus servicios est√°n usando el persist timer frecuentemente (puede ser s√≠ntoma de cuello de botella).

---

#### üîß `strace -p <PID>` o `lsof -p <PID>`

‚úÖ **Qu√© hace:**  Verifica si un proceso est√° bloqueado escribiendo en un socket cuyo receptor no lee.

`sendto(...) = EAGAIN (Resource temporarily unavailable)` 

üß† **Comentario:**  
Si tu app intenta escribir pero el receptor no lee, se bloquea ‚Üí el persist timer act√∫a.


## üìò Cap√≠tulo 23: TCP Keepalive Timer

### üß† Lo esencial que debes saber

- El **keepalive timer** permite a TCP **detectar si la otra parte de la conexi√≥n ha desaparecido** sin cerrarla correctamente.
- Est√° **desactivado por defecto** en muchas implementaciones, pero puede habilitarse a nivel de socket o sistema.
- Si una conexi√≥n est√° **inactiva** por un largo tiempo, TCP puede enviar paquetes **"keepalive"** (sin datos) para verificar si el otro extremo sigue presente.

---

### üîÅ ¬øC√≥mo funciona el TCP Keepalive?

1. La conexi√≥n TCP permanece **inactiva durante un tiempo prolongado**.
2. Si el **keepalive est√° activado**, tras cierto tiempo (`tcp_keepalive_time`) se env√≠a un paquete vac√≠o (ACK).
3. Si no hay respuesta, se env√≠an m√°s intentos (`tcp_keepalive_probes`) con cierto intervalo (`tcp_keepalive_intvl`).
4. Si tras varios intentos no hay respuesta, **la conexi√≥n se cierra**.

---

### üß™ Par√°metros importantes

| Par√°metro                      | Descripci√≥n                                                  |
|-------------------------------|--------------------------------------------------------------|
| `tcp_keepalive_time`          | Tiempo de inactividad antes de enviar el primer keepalive    |
| `tcp_keepalive_intvl`         | Intervalo entre cada intento                                 |
| `tcp_keepalive_probes`        | N√∫mero de intentos antes de cerrar la conexi√≥n               |

‚úÖ Se configuran v√≠a `sysctl` o en el c√≥digo de la app con `setsockopt()`.

---

### üë®‚Äçüíª Relevancia para backend

- √ötil para:
  - **Detectar clientes que se desconectaron sin cerrar conexi√≥n**
  - **Evitar que sockets queden colgados** eternamente (especialmente en conexiones largas)
  - Trabajos con:
    - WebSockets
    - Proxies persistentes
    - Conexiones base de datos

üß† Ayuda a liberar recursos cuando el otro extremo **ya no existe pero no se notific√≥**.

---

### üõ†Ô∏è Comandos / herramientas √∫tiles

| Herramienta / Comando                          | Funci√≥n                                                               |
|-----------------------------------------------|------------------------------------------------------------------------|
| `sysctl net.ipv4.tcp_keepalive_time`          | Ver/modificar tiempo de inicio de keepalive (en segundos)             |
| `ss -ti`                                       | Ver si una conexi√≥n tiene keepalive activo (algunos sistemas)         |
| `tcpdump`                                      | Ver paquetes ACK sin datos (keepalive packets)                        |
| `setsockopt()`                                 | Habilitar keepalive en sockets en apps propias                        |
| `netstat -s | grep keepalive`                 | Ver estad√≠sticas de keepalive                                         |

---

### üß™ Ejemplos pr√°cticos

#### üîß Ver configuraci√≥n del sistema

```bash
sysctl net.ipv4.tcp_keepalive_time
sysctl net.ipv4.tcp_keepalive_intvl
sysctl net.ipv4.tcp_keepalive_probes
```
üß† **Comentario:**  
Te dice cu√°nto tarda en enviarse el primer keepalive, con qu√© frecuencia se repite y cu√°ntos intentos se hacen antes de cerrar.

----------

#### üîß Activar keepalive en un socket (ej. Python)

```python
import socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
``` 

üß† **Comentario:**  
Ideal en servidores que gestionan muchas conexiones persistentes (como un backend con sockets largos o idle).

----------

### üîß Ver paquetes keepalive con tcpdump

`tcpdump 'tcp[13] & 0x10 != 0 and len <= 0'` 

üß† **Comentario:**  
Filtra ACKs sin datos (posibles keepalive TCP). No ver√°s payload, solo confirmaci√≥n de que el host sigue vivo.

----------

### üîß Estad√≠sticas de keepalive

`netstat -s | grep keepalive` 

üì§ **Salida posible:**

`20 keepalive probes sent 5 keepalive timeouts` 

üß† **Comentario:**  
√ötil para monitorear comportamiento en sistemas de producci√≥n que usan conexiones largas.


## üìò Cap√≠tulo 24: TCP Futures and Performance

### üß† Lo esencial que debes saber

Este cap√≠tulo explora **mejoras modernas y futuras del protocolo TCP**, especialmente aquellas orientadas a:

- Mejorar el **rendimiento**
- Reducir la **latencia**
- Soportar redes m√°s r√°pidas y complejas

Estas mejoras se han incorporado al stack TCP para **mantener su relevancia** frente a nuevos protocolos como **QUIC** y necesidades de alta velocidad (cloud, fibra, 5G‚Ä¶).

---

### üöÄ Extensiones modernas de TCP

| Mecanismo                  | Prop√≥sito                                                            |
|---------------------------|----------------------------------------------------------------------|
| **TCP Window Scaling**     | Permite usar ventanas de recepci√≥n > 64 KB                          |
| **TCP Timestamps (RFC 1323)** | Mejora c√°lculo de RTT y ayuda a evitar errores de secuencia     |
| **Selective Acknowledgments (SACK)** | Acelera recuperaci√≥n de p√©rdidas sin reenviar todo             |
| **ECN (Explicit Congestion Notification)** | Detecta congesti√≥n sin p√©rdida de paquetes                 |
| **Fast Open (TFO)**        | Env√≠a datos durante el handshake (menos latencia)                   |

üß† Estas extensiones requieren **compatibilidad en ambos extremos**.

---

### üìä M√©tricas de rendimiento en TCP

TCP mide y adapta su comportamiento usando:

- **RTT (Round-Trip Time)**: tiempo de ida y vuelta
- **RTO (Retransmission Timeout)**: cu√°nto esperar antes de retransmitir
- **CWND (Congestion Window)**: cu√°nto puede enviar sin congestionar la red
- **RWND (Receive Window)**: cu√°nto puede recibir el otro extremo

El rendimiento est√° limitado por:

```text
Throughput ‚âà min(cwnd, rwnd) / RTT
```

### üë®‚Äçüíª Relevancia para backend

Estas mejoras son clave si trabajas en:

-   Transferencia de archivos pesados (ej. S3, video, backups)
    
-   Alta concurrencia (muchas conexiones TCP simult√°neas)
    
-   Latencia ultra baja (trading, gaming, IoT en tiempo real)
    
-   Microservicios distribuidos en redes inestables
    

üìå Un mal uso de TCP (o su configuraci√≥n) puede:

-   Causar **cuellos de botella**
    
-   Provocar **p√©rdidas de rendimiento invisibles**
    
-   Afectar el **comportamiento de tus aplicaciones bajo carga**


## üõ†Ô∏è Comandos / herramientas √∫tiles

| Comando / Herramienta                    | Descripci√≥n                                                                 |
|------------------------------------------|-----------------------------------------------------------------------------|
| `ss -i`                                  | Muestra informaci√≥n detallada de conexiones TCP (RTT, cwnd, retrans, etc.) |
| `sysctl net.ipv4.tcp_window_scaling`     | Verifica si la ampliaci√≥n de ventana TCP est√° activada                     |
| `sysctl net.ipv4.tcp_sack`               | Comprueba si est√° activado el soporte de Selective Acknowledgment (SACK)   |
| `iperf3 --bidir`                         | Test de rendimiento TCP bidireccional entre dos nodos                      |
| `netstat -s`                             | Muestra estad√≠sticas acumuladas del stack TCP                              |
| `ethtool -k <interfaz>`                  | Muestra si la interfaz de red soporta offloading para mejorar rendimiento  |

----------

### üß™ Ejemplos pr√°cticos

#### üîß Ver uso de SACK y window scaling
```bash
sysctl net.ipv4.tcp_sack
sysctl net.ipv4.tcp_window_scaling
``` 

üì§ **Salida:**
```bash
net.ipv4.tcp_sack = 1
net.ipv4.tcp_window_scaling = 1
``` 

üß† **Comentario:**  
Ambos activados ‚Üí TCP m√°s eficiente en redes modernas con latencia y p√©rdida.

----------

#### üîß `ss -i`

‚úÖ **Qu√© hace:**  
Verifica par√°metros de rendimiento TCP por conexi√≥n.

`cwnd: 21, rtt: 30ms, rto: 200ms, retrans: 0` 

üß† **Comentario:**  
Te ayuda a ver el rendimiento real y detectar cuellos de congesti√≥n.

----------

#### üîß `iperf3 --bidir`

‚úÖ **Qu√© hace:**  
Prueba el rendimiento **de subida y bajada simult√°neamente** entre dos nodos.

`[SUM] 0.00-10.00 sec  2.0 GBytes  1.7 Gbits/sec  sender
[SUM] 0.00-10.00 sec  1.9 GBytes  1.6 Gbits/sec  receiver` 

üß† **Comentario:**  
Ideal para probar rendimiento real en producci√≥n o redes virtualizadas.

----------

#### üîß `ethtool -k eth0`

‚úÖ **Qu√© hace:**  
Verifica si est√°n activadas funciones de offload (como TCP checksum, TSO).

```bash
tcp-segmentation-offload: on
generic-receive-offload: on
``` 

üß† **Comentario:**  
Estas funciones alivian la CPU y mejoran rendimiento para tr√°fico TCP pesado.

----------

### üì¶ ¬øY el futuro?

TCP sigue evolucionando, pero:

-   Protocolos como **QUIC (basado en UDP)** est√°n ganando terreno, especialmente en web moderna.
    
-   Aun as√≠, **TCP sigue siendo el pilar de backend, bases de datos, APIs y microservicios**.


## üìò Cap√≠tulo 25: SNMP ‚Äì Simple Network Management Protocol


### üß† Lo esencial que debes saber

- **SNMP** es un protocolo de capa de aplicaci√≥n dise√±ado para **monitorizar y administrar dispositivos de red**: routers, switches, servidores, impresoras, etc.
- Usa **UDP (puerto 161)** para las consultas y **puerto 162** para recibir alertas (traps).
- Opera mediante una estructura de **pregunta/respuesta (GET, SET)** sobre una base de datos jer√°rquica llamada **MIB (Management Information Base)**.

---

### üß© Estructura de SNMP

| Componente      | Funci√≥n                                                                  |
|------------------|-------------------------------------------------------------------------|
| **Agent**         | Software que corre en el dispositivo gestionado                         |
| **Manager**       | Software que env√≠a comandos SNMP y recibe respuestas o traps            |
| **MIB**           | Base de datos jer√°rquica de variables gestionables (CPU, RAM, red...)   |
| **OID**           | Identificador √∫nico de cada variable dentro de la MIB                   |

Ejemplo de OID:  
```text
1.3.6.1.2.1.1.5.0 ‚Üí nombre del host
```

--- 

### üîÅ Operaciones b√°sicas
| Operaci√≥n SNMP | Descripci√≥n                                               |
|----------------|-----------------------------------------------------------|
| GET            | Solicita el valor de una variable (OID)                   |
| SET            | Modifica el valor de una variable (si est√° permitido)     |
| GET-NEXT       | Navega al siguiente OID dentro de la MIB                  |
| TRAP           | Alerta enviada autom√°ticamente por el agente al manager   |

---

### üîí Versiones de SNMP

| Versi√≥n  | Caracter√≠sticas                                                 |
|----------|-----------------------------------------------------------------|
| SNMPv1   | Simple, pero sin cifrado ni autenticaci√≥n                       |
| SNMPv2c  | M√°s eficiente, a√∫n sin seguridad real                           |
| SNMPv3   | A√±ade autenticaci√≥n, privacidad (cifrado) y control de acceso   |
üß† Hoy se recomienda usar **SNMPv3** por razones de seguridad.

---

### üë®‚Äçüíª Relevancia para backend

-   Aunque no lo uses directamente en tus APIs, **SNMP puede afectar o ayudar a monitorizar servicios backend**, como:
    
    -   Uso de CPU/RAM/puertos
        
    -   Estado de red en instancias backend
        
    -   Alerta temprana ante fallos de hardware o saturaci√≥n
        
-   Tambi√©n puedes integrar SNMP con herramientas como:
    
    -   **Nagios**, **Zabbix**, **Prometheus (con exporters)**

---

### üõ†Ô∏è Comandos / herramientas √∫tiles
| Comando / Herramienta                            | Funci√≥n                                                              |
|--------------------------------------------------|----------------------------------------------------------------------|
| `snmpget -v 2c -c public <host> <OID>`           | Obtiene valor de una variable SNMP                                  |
| `snmpwalk -v 2c -c public <host>`                | Lista m√∫ltiples OIDs de forma recursiva                             |
| `snmpset -v 2c -c private <host> <OID> type val` | Modifica el valor de una variable SNMP                              |
| `snmptrap`                                       | Env√≠a un trap manualmente                                           |
| `snmpd` / `snmptrapd`                            | Agente SNMP o receptor de traps                                     |
| `tcpdump port 161 or port 162`                   | Captura tr√°fico SNMP o traps SNMP                                   |

---

### üß™ Ejemplos pr√°cticos

---

#### üîß `snmpget -v 2c -c public 192.168.1.1 1.3.6.1.2.1.1.1.0`

‚úÖ **Qu√© hace:**  
Consulta el valor de un OID (en este caso, descripci√≥n del sistema).

`SNMPv2-MIB::sysDescr.0 = STRING: Linux server01 5.10.0-22-amd64 #1 SMP ...` 

üß† **Comentario:**  
Responde con la informaci√≥n b√°sica del sistema remoto. Ideal para validaciones simples.

----------

#### üîß `snmpwalk -v 2c -c public 192.168.1.1`

‚úÖ **Qu√© hace:**  
Explora la MIB desde un punto inicial (por defecto: `1.3.6.1`).

```bash
SNMPv2-MIB::sysName.0 = STRING: server01
SNMPv2-MIB::sysLocation.0 = STRING: Datacenter A
...
``` 

üß† **Comentario:**  
√ötil para inspeccionar qu√© variables est√°n disponibles en un dispositivo.

----------

#### üîß `snmpset -v 2c -c private 192.168.1.1 1.3.6.1.2.1.1.6.0 s "Nueva ubicaci√≥n"`

‚úÖ **Qu√© hace:**  Modifica un valor de la MIB (ej. ubicaci√≥n del host).

`SNMPv2-MIB::sysLocation.0 = STRING: Nueva ubicaci√≥n` 

üß† **Comentario:**  Necesita permisos y el string de comunidad de escritura (`private`).

----------

#### üîß `tcpdump udp port 161 or port 162`

‚úÖ **Qu√© hace:**  Captura tr√°fico SNMP (consultas) o traps SNMP (notificaciones).

`IP 192.168.1.1.161 > 192.168.1.100.1033: SNMP trap` 

üß† **Comentario:**  Muy √∫til para saber si se est√°n enviando alertas o si hay actividad SNMP sospechosa.


## üìò Cap√≠tulo 26: Telnet and Rlogin

### üß† Lo esencial que debes saber

- **Telnet** y **Rlogin** son protocolos de acceso remoto a trav√©s de **TCP/IP**, usados principalmente para controlar sistemas Unix/Linux desde otro host.
- Ambos permiten **conexi√≥n a l√≠nea de comandos remota**, pero **no son seguros**, ya que transmiten credenciales en texto plano.
- Usan TCP:
  - **Telnet**: puerto 23
  - **Rlogin**: puerto 513

Hoy en d√≠a est√°n **obsoletos en favor de SSH**, pero se estudian por su valor hist√≥rico y arquitectura de protocolo.

---

### üß© Diferencias entre Telnet y Rlogin

```markdown
| Caracter√≠stica     | Telnet                        | Rlogin                          |
|--------------------|-------------------------------|---------------------------------|
| Autenticaci√≥n      | Manual (usuario + password)   | Autom√°tica si `.rhosts` est√° configurado |
| Configuraci√≥n local| Nula                          | Usa la identidad del usuario local       |
| Compatibilidad     | Cualquier sistema TCP/IP      | Solo Unix/Linux                 |
| Seguridad          | Ninguna                       | Ninguna                         |
```

---

### üß† ¬øC√≥mo funciona Telnet?

-   Telnet usa TCP para abrir una sesi√≥n de terminal remota.
    
-   Se basa en una **negociaci√≥n inicial de opciones** (modo eco, tipo de terminal, etc.) con comandos especiales (`IAC`, `WILL`, `DO`, `DONT`, `WONT`).
    
-   Todo lo que escribes se env√≠a como entrada est√°ndar al host remoto.

---

### üë®‚Äçüíª Relevancia para backend (hoy en d√≠a)

-   Aunque ya **no se usa en producci√≥n**, **Telnet sigue siendo √∫til para pruebas r√°pidas** de puertos TCP abiertos.
    
    -   Ejemplo: `telnet <host> <puerto>` ‚Üí para probar conectividad a un servicio HTTP, SMTP, etc.
        
-   Tambi√©n es √∫til para:
    
    -   Ver si una aplicaci√≥n escucha correctamente
        
    -   Depurar firewalls y reglas de red
        
-   **Rlogin** pr√°cticamente ha desaparecido.

### üõ†Ô∏è Comandos / herramientas √∫tiles

| Comando / Herramienta       | Funci√≥n                                                                 |
|-----------------------------|-------------------------------------------------------------------------|
| `telnet <host> <puerto>`    | Prueba conexi√≥n TCP manual (cualquier puerto)                          |
| `telnet`                    | Inicia cliente Telnet interactivo                                      |
| `rlogin <host>`             | Inicia sesi√≥n remota si est√° permitido por `.rhosts`                  |
| `tcpdump port 23 or port 513` | Captura sesiones Telnet o Rlogin                                    |
| `ss -t -a` / `netstat -tn`  | Verifica si hay conexiones abiertas en esos puertos                   |

### üß™ Ejemplos pr√°cticos

----------

#### üîß Conexi√≥n b√°sica con Telnet

`telnet example.com 80` 

üì§ Salida esperada:

```bash
Trying 93.184.216.34...
Connected to example.com. Escape  character  is  '^]'.
``` 

üß† **Comentario:**  
Ideal para comprobar si un servicio escucha y responde por TCP (como HTTP, SMTP, Redis‚Ä¶).

----------

#### üîß Simular petici√≥n HTTP con Telnet
`GET / HTTP/1.1 Host: example.com` 

üì§ Respuesta esperada:

```bash
HTTP/1.1 200 OK
Content-Type: text/html ...
``` 

üß† **Comentario:**  
Puedes simular peticiones HTTP sin navegador ni curl. Muy √∫til para depuraci√≥n b√°sica.

----------

#### üîß Capturar tr√°fico con tcpdump

`sudo tcpdump -n port 23` 

üì§ Salida:

`IP  192.168.1.50.53920 > 192.168.1.1.23: Flags [P.], length 28` 

üß† **Comentario:**  
Muestra sesi√≥n Telnet activa. Puedes ver comandos y respuestas sin cifrar (¬°no usar en producci√≥n!).

----------

### üîí Nota de seguridad

**No uses Telnet ni Rlogin en entornos productivos o p√∫blicos**:

-   Transmiten usuario y contrase√±a en texto plano.
    
-   Son vulnerables a sniffing y ataques MITM.
    
-   Siempre usa **SSH** como alternativa moderna y segura.


## üìò Cap√≠tulo 27: FTP ‚Äì File Transfer Protocol

### üß† Lo esencial que debes saber

- **FTP** (File Transfer Protocol) es uno de los protocolos m√°s antiguos de la capa de aplicaci√≥n, dise√±ado para **transferencia de archivos** entre cliente y servidor.
- Opera sobre **TCP**, usando dos conexiones separadas:
  - **Puerto 21**: conexi√≥n de control (comandos, respuestas)
  - **Puerto 20** o din√°mico: conexi√≥n de datos (para los archivos)

- FTP puede operar en dos modos:
  - **Activo**: el servidor abre la conexi√≥n de datos al cliente.
  - **Pasivo**: el cliente abre ambas conexiones (m√°s com√∫n detr√°s de NAT/firewalls).

---

### üîÅ Flujo de conexi√≥n FTP

1. Cliente abre conexi√≥n TCP al puerto 21 (control).
2. Env√≠a usuario/contrase√±a.
3. Solicita operaci√≥n (`RETR`, `STOR`, `LIST`, etc.).
4. Se abre **una segunda conexi√≥n TCP** para los datos.
5. Se transfiere el archivo.
6. Se cierra la conexi√≥n de datos; la de control puede quedar abierta.

---

### üîí Seguridad

| Variante | Descripci√≥n                                  |
|----------|----------------------------------------------|
| FTP      | Sin cifrado, todo en texto plano             |
| FTPS     | FTP sobre TLS (SSL)                          |
| SFTP     | Protocolo diferente, basado en SSH           |

üß† **SFTP** es el est√°ndar seguro moderno, **no confundirlo con FTP sobre TLS (FTPS)**.

---

### üë®‚Äçüíª Relevancia para backend

- FTP todav√≠a se usa en:
  - Integraciones con sistemas legados
  - Transferencia de grandes vol√∫menes de archivos batch
  - Automatizaciones con scripts
- Problemas comunes:
  - Firewalls bloqueando el canal de datos
  - Configuraciones NAT que impiden el modo activo
  - Exposici√≥n de credenciales (por ser texto plano)

---

### üõ†Ô∏è Comandos / herramientas √∫tiles

```markdown
| Comando / Herramienta             | Funci√≥n                                                                 |
|----------------------------------|--------------------------------------------------------------------------|
| `ftp <host>`                     | Inicia una sesi√≥n FTP interactiva                                       |
| `ncftp`, `lftp`                  | Clientes FTP mejorados                                                  |
| `curl ftp://host/file`           | Descargar archivo por FTP usando curl                                   |
| `tcpdump port 21 or port 20`     | Captura conexiones de control y datos FTP                               |
| `ss -t state established`        | Verifica conexiones TCP abiertas                                        |
| `vsftpd`, `proftpd`              | Servidores FTP comunes en Linux                                         |
```

### üß™ Ejemplos pr√°cticos

----------

#### üîß Conexi√≥n FTP simple
`ftp ftp.gnu.org` 

üì§ Salida:

```bash
Connected to ftp.gnu.org. 220 GNU FTP server ready.
Name (ftp.gnu.org:you): anonymous 331 Please specify the password. Password:  230 Login successful.
``` 

üß† **Comentario:**  Muchos servidores FTP p√∫blicos aceptan `anonymous` como usuario.

----------

### üîß Descargar archivo con curl
`curl -O ftp://ftp.gnu.org/gnu/bash/bash-5.1.tar.gz` 

üß† **Comentario:**  Descarga directa v√≠a FTP sin abrir una sesi√≥n interactiva.

----------

### üîß FTP pasivo con lftp

`lftp -u user,pass -e "set ftp:passive-mode on; get data.csv; bye" ftp.example.com` 

üß† **Comentario:**  Ideal en scripts o detr√°s de NAT/firewall. LFTP soporta autenticaci√≥n y scripts complejos.

----------

### üîß Captura de tr√°fico FTP

`tcpdump -n port 21 or port 20` 

üì§ Salida t√≠pica:
`IP  192.168.1.100.21 > 192.168.1.50.51234: Flags [P.], FTP: 220 Welcome` 

üß† **Comentario:**  Puedes ver login, comandos y respuestas. ¬°Ojo! Todo en texto plano.

----------

### üîê Recomendaci√≥n actual

Usar **SFTP o HTTPS para transferencias de archivos seguras**. FTP debe restringirse a redes internas o entornos controlados.



## üìò Cap√≠tulo 28: SMTP ‚Äì Simple Mail Transfer Protocol

### üß† Lo esencial que debes saber

- **SMTP** es el protocolo est√°ndar de la capa de aplicaci√≥n para **env√≠o de correo electr√≥nico** entre servidores.
- Utiliza **TCP puerto 25** por defecto (aunque tambi√©n se usa 587 para env√≠o autenticado y 465 para SMTP seguro).
- Funciona mediante comandos de texto plano que definen la comunicaci√≥n entre cliente y servidor de correo.

---

### üß© Flujo b√°sico de env√≠o de correo con SMTP

1. Cliente abre conexi√≥n TCP al servidor SMTP (puerto 25/587).
2. Se intercambian comandos como:
   - `HELO` o `EHLO` ‚Üí saludo
   - `MAIL FROM` ‚Üí indica remitente
   - `RCPT TO` ‚Üí indica destinatario
   - `DATA` ‚Üí cuerpo del mensaje
   - `QUIT` ‚Üí cierra la sesi√≥n

3. Si el servidor acepta, el mensaje se entrega o enruta.

---

### üì¶ Comandos SMTP comunes

```markdown
| Comando     | Descripci√≥n                                |
|-------------|--------------------------------------------|
| HELO/EHLO   | Saludo inicial, identifica al cliente      |
| MAIL FROM   | Define el remitente del correo             |
| RCPT TO     | Define el destinatario                     |
| DATA        | Inicia el cuerpo del mensaje               |
| RSET        | Resetea la sesi√≥n                          |
| QUIT        | Cierra la conexi√≥n                         |
```

### üîí Seguridad y autenticaci√≥n

```bash
| Puerto | Uso                                           |
|--------|-----------------------------------------------|
| 25     | Env√≠o entre servidores (sin autenticaci√≥n)     |
| 587    | Env√≠o autenticado (STARTTLS obligatorio)       |
| 465    | Env√≠o autenticado con TLS directo (legacy)     |
```
    

----------

### üë®‚Äçüíª Relevancia para backend

-   Si tu app env√≠a correos (registro, notificaciones, alertas):
    
    -   Necesitas configurar SMTP correctamente
        
    -   Debes manejar fallos como timeouts, respuestas 5xx, etc.
        
-   Integraciones t√≠picas:
    
    -   **Correo transaccional (SendGrid, Mailgun, SES)**
        
    -   **Servidores internos (Postfix, Exim)**
        
-   Es com√∫n usar librer√≠as (como `nodemailer`, `smtplib`, etc.), pero entender el protocolo ayuda a depurar errores.

### üõ†Ô∏è Comandos / herramientas √∫tiles
| Herramienta / Comando               | Funci√≥n                                                             |
|-------------------------------------|----------------------------------------------------------------------|
| `telnet <host> 25`                  | Probar conexi√≥n SMTP y enviar comandos manualmente                  |
| `openssl s_client -starttls smtp -connect <host>:587` | Inicia sesi√≥n segura STARTTLS                                     |
| `swaks`                             | Herramienta avanzada para probar SMTP                               |
| `postfix`, `exim`, `sendmail`       | Servidores SMTP comunes                                             |
| `tcpdump port 25 or port 587`       | Captura tr√°fico SMTP para debugging                                 |


### üß™ Ejemplos pr√°cticos

#### üîß Enviar correo manual con Telnet (no seguro)


`telnet smtp.example.com 25` 

```bash
EHLO myserver.local
MAIL FROM:<user@example.com>
RCPT TO:<dest@example.com>
DATA
Subject: Prueba SMTP

Hola, esto es un test.
.
QUIT
``` 

üß† **Comentario:**  Ideal para entender c√≥mo funciona SMTP por dentro y ver errores como 550 (user unknown).


#### üîß Prueba de conexi√≥n segura con OpenSSL

`openssl s_client -starttls smtp -connect smtp.gmail.com:587` 

üì§ Salida: TLS handshake + sesi√≥n SMTP

üß† **Comentario:**  
√ötil para validar certificados, autenticaci√≥n y cifrado con proveedores reales.

----------

#### üîß Env√≠o completo con `swaks`
```bash
swaks --to test@ejemplo.com --from user@tudominio.com --server smtp.tudominio.com --auth LOGIN --auth-user user --auth-password secret
``` 

üß† **Comentario:**  
`swaks` permite probar de forma avanzada sin escribir comandos manualmente.

----------

### üìå C√≥digos de respuesta SMTP (algunos comunes)
| C√≥digo | Significado                              |
|--------|-------------------------------------------|
| 220    | Servicio listo                            |
| 250    | Acci√≥n completada correctamente           |
| 354    | Esperando cuerpo del mensaje (despu√©s de DATA) |
| 421    | Servicio no disponible                    |
| 450/550| Problemas con la entrega (ej. no existe el destinatario) |
| 530    | Requiere autenticaci√≥n                    |

---

## üìò Cap√≠tulo 29: NFS ‚Äì Network File System

### üß† Lo esencial que debes saber

- **NFS** (Network File System) permite acceder a **archivos remotos como si fueran locales**, a trav√©s de la red.
- Es un protocolo de **sistema de archivos distribuido**, desarrollado por Sun Microsystems.
- Se basa en **RPC (Remote Procedure Call)**, y usa **TCP o UDP** como transporte.
- Muy usado en entornos Linux/Unix para:
  - Montar vol√∫menes compartidos
  - Compartir datos entre nodos
  - Centralizar almacenamiento en servidores

---

### üß© Arquitectura de NFS

```markdown
| Componente         | Funci√≥n                                                           |
|--------------------|-------------------------------------------------------------------|
| Cliente NFS        | Sistema que accede a archivos remotos                             |
| Servidor NFS       | Provee los archivos compartidos                                    |
| Mount Daemon (`rpc.mountd`) | Maneja solicitudes de montaje desde clientes           |
| NFS Daemon (`nfsd`) | Procesa solicitudes de lectura/escritura                         |
| Portmapper (`rpcbind`) | Asigna puertos din√°micos a servicios RPC                      |
```
---

### üîÅ Funcionamiento general

1.  El cliente se comunica con el `portmapper` del servidor para obtener puertos.
    
2.  Solicita montar un recurso compartido con `rpc.mountd`.
    
3.  Las operaciones de archivo (open, read, write, etc.) se gestionan con `nfsd` a trav√©s de RPC.

---

### üì¶ Versiones de NFS
| Versi√≥n | Caracter√≠sticas principales                                              |
|---------|-------------------------------------------------------------------------|
| v2      | Muy simple, usa UDP, tama√±o limitado                                    |
| v3      | Soporta TCP/UDP, mayor rendimiento, errores m√°s detallados             |
| v4      | Soporta autenticaci√≥n, ACLs, multiplexaci√≥n en un solo puerto TCP 2049 |
üß† Hoy en d√≠a, **NFSv4** es la versi√≥n recomendada.

---

### üîí Seguridad

-   NFS tradicional depende de **UID/GID** del sistema operativo cliente.
    
-   Para mejorar la seguridad:
    
    -   Usa **NFSv4** con autenticaci√≥n Kerberos (`sec=krb5`)
        
    -   Monta recursos de solo lectura si no necesitas escritura
        
    -   A√≠sla redes NFS detr√°s de firewalls
        

----------

### üë®‚Äçüíª Relevancia para backend

-   NFS se usa para:
    
    -   Compartir archivos entre contenedores o nodos
        
    -   Montar recursos en entornos CI/CD
        
    -   Mantener datos consistentes entre servicios distribuidos
        
-   En Kubernetes, puede ser backend de vol√∫menes persistentes (PV/PVC)
    
-   Problemas comunes:
    
    -   Latencia ‚Üí afecta rendimiento
        
    -   Desincronizaci√≥n de permisos UID/GID
        
    -   Fallos de red ‚Üí bloqueos en operaciones de archivo
        

----------

### üõ†Ô∏è Comandos / herramientas √∫tiles
| Comando / Herramienta               | Funci√≥n                                                        |
|------------------------------------|-----------------------------------------------------------------|
| `showmount -e <host>`              | Ver recursos exportados por el servidor NFS                    |
| `mount -t nfs <host>:/ruta /mnt`   | Montar recurso NFS manualmente                                 |
| `df -h` / `mount`                  | Ver si el recurso est√° montado correctamente                   |
| `rpcinfo -p <host>`                | Ver servicios RPC activos (incluidos NFS)                      |
| `tcpdump port 2049`                | Captura tr√°fico NFS                                            |
| `exportfs -v`                      | Ver recursos exportados (servidor NFS)                         |

----------

### üß™ Ejemplos pr√°cticos

#### üîß Ver recursos compartidos con `showmount`

`showmount -e nfs-server.local` 

üì§ Salida:

```bash
Export list for nfs-server.local:
/home/projects   192.168.1.0/24
``` 

üß† **Comentario:**  Muestra qu√© directorios est√°n disponibles para montar.

----------

#### üîß Montar un recurso NFS
`sudo mount -t nfs nfs-server.local:/home/projects /mnt/nfs` 

üß† **Comentario:**  Monta el recurso NFS en `/mnt/nfs`. Puede automatizarse en `/etc/fstab`.

----------

#### üîß Ver si el recurso est√° activo

`df -h | grep nfs` 

üì§ Salida: `nfs-server.local:/home/projects   100G   55G   45G  55% /mnt/nfs` 

üß† **Comentario:**  Confirma que el sistema de archivos remoto est√° montado correctamente.

----------

#### üîß Ver puertos RPC/NFS activos

`rpcinfo -p nfs-server.local` 

üì§ Salida: `100003 3 tcp 2049 nfs 100005 1 udp 631 mountd` 

üß† **Comentario:**  √ötil si NFS no est√° funcionando: puedes confirmar si los servicios est√°n corriendo.

### üö´ Nota sobre rendimiento
-   NFS es m√°s r√°pido con TCP y buffers grandes (`rsize`, `wsize`)
-   Puedes usar opciones de montaje como:

```bash
mount -t nfs -o rw,noatime,nolock,nfsvers=4,rsize=1048576,wsize=1048576 ...

```
---

## üìò Cap√≠tulo 30: Otras Aplicaciones TCP/IP

### üß† Lo esencial que debes saber

Este cap√≠tulo presenta una **variedad de aplicaciones que usan TCP/IP**, adem√°s de las ya tratadas en cap√≠tulos anteriores. Aunque algunas son menos conocidas hoy, ofrecen una visi√≥n general de c√≥mo **la pila TCP/IP soporta distintos tipos de servicios**.

El objetivo es mostrar la **diversidad de usos** que puede tener TCP/IP, desde login remoto hasta reloj en red.

---

### üì¶ Aplicaciones destacadas

```markdown
| Aplicaci√≥n    | Protocolo(s) | Puerto(s) | Descripci√≥n breve                                     |
|---------------|--------------|-----------|--------------------------------------------------------|
| Daytime       | TCP/UDP      | 13        | Devuelve la fecha y hora como texto                   |
| Time          | TCP/UDP      | 37        | Devuelve la hora como entero de 32 bits               |
| Echo          | TCP/UDP      | 7         | Devuelve todo lo que recibe (testing/debug)          |
| Discard       | TCP/UDP      | 9         | Descarta todo lo recibido (medici√≥n de rendimiento)  |
| Chargen       | TCP/UDP      | 19        | Devuelve cadenas repetidas (carga artificial)        |
| Whois         | TCP          | 43        | Consultas de nombres de dominio o usuarios           |
```
üß† Muchas de estas aplicaciones son **m√°s √∫tiles en pruebas de red que en producci√≥n real** hoy en d√≠a.

### üîí Consideraciones de seguridad
-   Estas aplicaciones suelen estar **deshabilitadas por defecto** por razones de seguridad.
-   Algunas pueden ser usadas maliciosamente (DoS, amplificaci√≥n).
-   Solo deber√≠an activarse en redes de prueba o cerradas.

### üë®‚Äçüíª Relevancia para backend
Aunque estas aplicaciones no se usan directamente en desarrollo backend, son **muy √∫tiles para**:

-   **Probar latencia**, conectividad y rendimiento b√°sico
-   Simular tr√°fico o carga en entornos controlados
-   Aprender c√≥mo se comportan los servicios TCP/UDP simples
-   Desarrollar herramientas personalizadas de red o diagn√≥stico


#### üõ†Ô∏è Comandos / herramientas √∫tiles
| Comando / Herramienta              | Funci√≥n                                                             |
|-----------------------------------|----------------------------------------------------------------------|
| `telnet <host> 13`                | Consultar servicio Daytime                                          |
| `nc <host> 19`                    | Conectarse a Chargen (genera carga)                                 |
| `tcpdump port 7 or port 9`        | Capturar tr√°fico Echo o Discard                                     |
| `nmap --script time`              | Consultar puertos 13/37 si est√°n abiertos (servicios de tiempo)     |
| `xinetd` / `inetd`                | Servicios de red que pueden lanzar estas apps de red (legacy)       |

### üß™ Ejemplos pr√°cticos

----------

#### üîß Probar Daytime con Telnet
`telnet time.nist.gov 13` 

üì§ Salida esperada: `58256  24-04-17  12:34:56  00  0  0  465.1  UTC(NIST)` 

üß† **Comentario:**  Devuelve la hora exacta. A√∫n hay servidores p√∫blicos disponibles.

----------

#### üîß Usar `nc` con Echo o Chargen

`nc localhost 7` 

‚úçÔ∏è Escribe algo y ver√°s que se te devuelve (echo).

`nc localhost 19` 

üì§ Salida: `!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[...\n` 

üß† **Comentario:**  
Chargen genera cadenas repetitivas: √∫til para pruebas de carga o throughput.

----------

#### üîß Captura de tr√°fico simple
`sudo tcpdump port 13 or port 37` 

üß† **Comentario:**  Puedes observar c√≥mo fluyen los paquetes de las apps de tiempo en texto o binario.

----------

### üì¶ Conclusi√≥n del libro

-   TCP/IP soporta una **ampl√≠sima variedad de aplicaciones**, desde HTTP y SMTP hasta herramientas de depuraci√≥n y administraci√≥n.
    
-   Aunque algunas de estas aplicaciones est√°n obsoletas, son valiosas para:
    
    -   Comprender c√≥mo opera TCP/IP
        
    -   Probar configuraciones de red
        
    -   Analizar tr√°fico y depurar conectividad
        
-   Las herramientas simples basadas en TCP y UDP **siguen siendo esenciales para pruebas, aprendizaje y observabilidad**.

## üìò Ap√©ndice A ‚Äì El programa `tcpdump`

El ap√©ndice A describe c√≥mo funciona internamente `tcpdump`, una herramienta esencial para **capturar, filtrar y analizar tr√°fico de red**. Tambi√©n cubre c√≥mo accede a los datos de red en distintos sistemas operativos y sus implicaciones de seguridad.

---

### üîç ¬øQu√© es `tcpdump`?

- Es una herramienta de l√≠nea de comandos que permite observar paquetes a nivel IP y superiores.
- Usa **`libpcap`** (Packet Capture Library) para acceder a los paquetes directamente desde la interfaz de red.
- Puede funcionar con filtros para mostrar solo el tr√°fico relevante (ej. `tcp port 80`).

---

### A.1 BSD Packet Filter (BPF)

- Sistema **eficiente y seguro** para capturar paquetes en sistemas tipo BSD.
- BPF opera en **espacio de kernel**, aplicando filtros antes de pasar datos al usuario ‚Üí evita overhead.
- Ventajas:
  - Bajo impacto en el rendimiento.
  - Evita copiar todos los paquetes innecesarios al espacio de usuario.
- Estructura:
  - BPF es como una **m√°quina virtual peque√±a** que ejecuta filtros (compilados desde expresiones `tcpdump`).
  - Ejemplo: `tcpdump tcp port 80` se convierte en instrucciones de BPF.

üß† **Hoy es el est√°ndar en sistemas como FreeBSD, macOS, y Linux (v√≠a libpcap).**

---

### A.2 SunOS Network Interface Tap (`/dev/nit`)

- M√©todo propietario de captura usado en sistemas **SunOS 4.x**.
- El dispositivo especial `/dev/nit` permite leer paquetes crudos desde interfaces.
- Problemas:
  - Menos eficiente que BPF.
  - Necesita acceso root.
  - Depende de comportamiento del driver de red.
- Ha sido reemplazado por BPF o DLPI en versiones modernas.

---

### A.3 SVR4 Data Link Provider Interface (DLPI)

- Interfaz est√°ndar en **System V Release 4 y Solaris** para acceso a capa de enlace.
- M√°s generalista que BPF, pero tambi√©n m√°s compleja de programar.
- Requiere saber el tipo de enlace y negociar la conexi√≥n (estilo conexi√≥n orientada).
- A menudo se usa con herramientas como `snoop` o implementaciones personalizadas de `tcpdump`.

---

### A.4 Salida de `tcpdump`

- Muestra informaci√≥n de cabeceras IP/TCP/UDP/ICMP de manera legible.
- Ejemplo:

```bash
IP 192.168.1.10.50514 > 93.184.216.34.80: Flags [S], seq 100, win 8192
```

-   Puedes observar:
    
    -   Direcci√≥n origen/destino y puerto
        
    -   Flags TCP (`SYN`, `ACK`, `FIN`)
        
    -   N√∫meros de secuencia, longitud de ventana, TTL
        

üõ† Muy √∫til para detectar:

-   Problemas de handshake
    
-   Retransmisiones
    
-   Latencia, p√©rdida de paquetes

### A.5 Consideraciones de seguridad

-   `tcpdump` requiere privilegios elevados (root o capacidades especiales) porque accede a interfaces de red crudas.
    
-   Riesgos:
    
    -   Puede **leer todo el tr√°fico no cifrado** (contrase√±as, cookies, tokens).
        
    -   Podr√≠a usarse para espionaje si se ejecuta en secreto.
        
-   Recomendaciones:
    
    -   Limitar acceso al binario (`chmod`, `sudoers`)
        
    -   Usar filtros precisos (para capturar solo lo necesario)
        
    -   Registrar qui√©n accede al sistema cuando se usa

### A.6 Opci√≥n de depuraci√≥n de socket (`SO_DEBUG`)

-   Permite activar el modo debug en un socket a trav√©s de la opci√≥n `SO_DEBUG`.
    
-   √ötil para ver internamente c√≥mo evoluciona una conexi√≥n TCP:
    
    -   Estados (`SYN_SENT`, `ESTABLISHED`, `TIME_WAIT`)
        
    -   N√∫mero de retransmisiones
        
    -   Cambios en ventana de congesti√≥n
        

üß† No todos los sistemas exponen esta funcionalidad, y requiere acceso a estructuras internas del kernel.

----------

### ‚úÖ En resumen:

-   `tcpdump` es una herramienta **imprescindible para depurar redes**.
    
-   Su funcionamiento var√≠a seg√∫n el sistema operativo:
    
    -   **BPF** en BSD/macOS/Linux modernos.
        
    -   **DLPI** en Solaris/SVR4.
        
    -   **/dev/nit** en SunOS antiguos.
        
-   Su uso debe ser **cauteloso y controlado**, especialmente en entornos productivos.
    
-   Con `tcpdump` y un buen filtro, puedes inspeccionar casi cualquier cosa en la red.


## üìò Ap√©ndice B ‚Äì Relojes de los ordenadores (Computer Clocks)

### üß† Lo esencial que debes saber

Los protocolos TCP/IP, especialmente aquellos como **TCP, ICMP y NTP**, dependen fuertemente de **mediciones de tiempo precisas**. Este ap√©ndice explica c√≥mo funcionan los relojes del sistema y por qu√© **la sincronizaci√≥n es crucial** en redes.

---

### üïì Tipos de relojes en un sistema

| Tipo de reloj           | Uso principal                                      |
|-------------------------|----------------------------------------------------|
| Reloj de hardware (RTC) | Mantiene la hora incluso apagado el sistema       |
| Reloj del sistema       | Se actualiza con cada "tick" del sistema operativo |
| Reloj de red (NTP)      | Corrige y sincroniza la hora con servidores externos |

---

### ‚è±Ô∏è Medici√≥n de tiempo en protocolos

- **TCP** mide el **RTT (Round-Trip Time)** para calcular los timeouts.
- **ICMP (ping)** tambi√©n mide RTT entre hosts.
- **NTP (Network Time Protocol)** ajusta el reloj del sistema en base a una fuente externa confiable.

üß† Si los relojes est√°n desincronizados entre sistemas, puede haber problemas en:
- Logs (eventos en orden incorrecto)
- Autenticaci√≥n (tokens expiran demasiado pronto o tarde)
- Protocolos sensibles a la latencia (ej. retransmisiones TCP)

---

### ‚ö†Ô∏è Problemas comunes con relojes

| Problema             | Efecto                                                |
|----------------------|--------------------------------------------------------|
| **Drift (deriva)**   | El reloj del sistema se adelanta o atrasa lentamente |
| **Skew (desfase)**   | Diferencia fija entre dos relojes                     |
| **Jitter (variaci√≥n)**| Cambios peque√±os en los tiempos medidos              |

Ejemplo: Un reloj que gana 1 segundo por hora tendr√° un **drift de ~24 segundos por d√≠a**.

---

### üîß Soluci√≥n: NTP

- El protocolo **NTP** permite mantener relojes sincronizados con precisi√≥n de milisegundos.
- Sincroniza con servidores jer√°rquicos:
  - **Stratum 0**: relojes at√≥micos o GPS
  - **Stratum 1**: servidores conectados directamente a stratum 0
  - **Stratum 2+**: clientes sincronizados en cascada

‚úÖ Recomendado configurar **servicios NTP como `chronyd` o `ntpd`** en cualquier servidor o sistema distribuido.

---

### üë®‚Äçüíª Relevancia para backend y redes

- Si trabajas con **sistemas distribuidos, microservicios, autenticaci√≥n o logs**, la hora **debe estar bien sincronizada**.
- Desincronizaci√≥n puede causar:
  - Incompatibilidad con JWT, OAuth
  - Inconsistencias en bases de datos
  - Fallos en debugging (logs fuera de orden)
- **Buenas pr√°cticas**:
  - Usar NTP o Chrony
  - Verificar con `timedatectl status` o `ntpq -p`
  - Sincronizar todos los nodos con el mismo servidor o pool

---

### ‚úÖ En resumen

- Los relojes son **cr√≠ticos para el correcto funcionamiento de redes y aplicaciones**.
- Todos los sistemas deben tener **NTP activado** y funcionando.
- El conocimiento de c√≥mo el tiempo afecta a TCP/IP ayuda a entender **timeouts, retransmisiones, errores de autenticaci√≥n, y orden de eventos**.

---
